/*
 Navicat Premium Data Transfer

 Source Server         : blog
 Source Server Type    : MySQL
 Source Server Version : 50562
 Source Host           : 106.52.232.16:3306
 Source Schema         : myblog

 Target Server Type    : MySQL
 Target Server Version : 50562
 File Encoding         : 65001

 Date: 14/10/2019 11:06:40
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for blogs
-- ----------------------------
DROP TABLE IF EXISTS `blogs`;
CREATE TABLE `blogs`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `createtime` bigint(20) NOT NULL,
  `author` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `subtitle` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `classify` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `count` int(11) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 117 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of blogs
-- ----------------------------
INSERT INTO `blogs` VALUES (82, 'Git简单生成生成公钥和私钥方法', 'fuwenben963&lt;h2&gt;Git配置&lt;/h2&gt;&lt;p&gt;Git安装完之后，需做最后一步配置。打开git bash，分别执行以下两句命令&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;git config --global user.name &#039;&#039;liuwk&#039;&#039;\n\ngit config --global user.email &#039;&#039;1834183435@qq.com&#039;&#039;\n&lt;/pre&gt;&lt;p&gt;用户名看自己喜欢起，一般都是起些容易记的，亦或者某个简称，邮箱选自己邮箱即可。（值得一提的是，我第一次生成的时候并没有执行上两句命令，而是直接在配置那里写邮箱和用户名，生成的公钥匙直接显示我的邮箱，后来拿去用不了；后来我有一步一步写的时候生成的公钥其实最后显示的并不是邮箱，而是本机名，当时我一直以为显示邮箱是对的，后面也是别人指点才得知。当然，具体什么原因我不明白，菜鸟一枚，欢迎补充！）&lt;/p&gt;&lt;h2&gt;SSH配置&lt;/h2&gt;&lt;p&gt;1、打开 git bash&lt;/p&gt;&lt;p&gt;2、执行生成公钥和私钥的命令：&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;code&gt;ssh-keygen -t rsa&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;并按回车3下（为什么按三下，是因为有提示你是否需要设置密码，如果设置了每次使用Git都会用到密码，一般都是直接不写为空，直接回车就好了）。会在一个文件夹里面生成一个私钥&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;code&gt;id_rsa&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;和一个公钥&lt;/p&gt;&lt;p&gt;&lt;code&gt;id_rsa.pub&lt;/code&gt;&lt;/p&gt;&lt;p&gt;（可执行start ~ 命令，生成的公私钥在 .ssh的文件夹里面）&lt;/p&gt;&lt;p&gt;3、执行查看公钥的命令：&lt;/p&gt;&lt;p&gt;&lt;code&gt;cat ~/.ssh/id_rsa.pub&lt;/code&gt;&lt;/p&gt;fuwenben963', 1566641051777, 'liuwk', 'Git简单生成生成公钥和私钥方法', '3', 3);
INSERT INTO `blogs` VALUES (84, 'vue基于七牛云 上传图片、视频', 'fuwenben963&lt;p&gt;&lt;strong&gt;引入依赖&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;import request from &#039;./request&#039;&amp;nbsp;&amp;nbsp;//这是基于 axios封装的请求\nvar qiniu = require(&#039;qiniu-js&#039;)&amp;nbsp;//引入 qiniu\nimport { getTimeForQiniu } from &#039;./date&#039;&amp;nbsp;&amp;nbsp;//这个&amp;nbsp;只是为了生成时间戳路径\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;先根据后台获取token&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;export function getQiniuToken() {\n&amp;nbsp;&amp;nbsp;return request({\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;url: &#039;&amp;nbsp;&amp;nbsp;&#039;,&amp;nbsp;&amp;nbsp;//&amp;nbsp;对应后台token 请求接口&amp;nbsp;\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;method: &#039;post&#039;,\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// params\n&amp;nbsp;&amp;nbsp;}).then(res =&amp;gt; res.data.data).catch(e =&amp;gt; {\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;console.error(&quot;获取七牛云token失败&quot;, e)\n&amp;nbsp;&amp;nbsp;})\n}\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;七牛云方法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;export async function uploadQinuImage(file) {\n&amp;nbsp;&amp;nbsp;var token = await getQiniuToken()\n&amp;nbsp;&amp;nbsp;var key = getTimeForQiniu() + file.name\n&amp;nbsp;&amp;nbsp;var config = {\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// useCdnDomain: true,\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;region: qiniu.region.z2,\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;uptoken: token,\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;domain: &#039;&amp;nbsp;&#039;,&amp;nbsp;&amp;nbsp;&amp;nbsp;//配置好的七牛云域名&amp;nbsp;如&amp;nbsp;&amp;nbsp;https://cdn.qniyun.com/\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;unique_names: true,\n&amp;nbsp;&amp;nbsp;};\n&amp;nbsp;&amp;nbsp;var putExtra = {\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// fname: file.name,\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// params: {},\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// mimeType: [] || null\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;...config,\n&amp;nbsp;&amp;nbsp;}\n&amp;nbsp;&amp;nbsp;var observable = qiniu.upload(file, key, token, putExtra, config)\n&amp;nbsp;&amp;nbsp;return new Promise((resolve, reject) =&amp;gt; {\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;var subscription = observable.subscribe({\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;error(err) {\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;reject(data)\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;},\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;complete(data) {\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;data.path = `&amp;nbsp;`&amp;nbsp;//拼上七牛云域名&amp;nbsp;如&amp;nbsp;&amp;nbsp;https://cdn.qniyun.com/ ${data.key}\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;resolve(data)\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}) // 上传开始\n&amp;nbsp;&amp;nbsp;})\n\n}\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;导出方法&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;export default function uploadImage(file) {\n&amp;nbsp;&amp;nbsp;return uploadQinuImage(file)\n}\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;七牛云组件引用&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;&amp;nbsp;&amp;nbsp;import upload from &quot;@/utils/upload&quot;;\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;传上 files流&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;uploadImg(e) {\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;let that = this;\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;let files = e.target.files[0];\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;upload(files).then(res =&amp;gt; {\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;let obj = {\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;url: res.path,\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;type: &#039;IMAGE&#039;,\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;size: res.fsize,\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;key: res.key,\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;thumb: res.path\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;POST_RESOURCES(obj).then(res =&amp;gt; {\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Alert.success(&#039;上传成功&#039;);\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.getList();\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});\n\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;fuwenben963', 1566641217787, 'liuwk', 'vue基于七牛云 上传图片、视频', '3', 33);
INSERT INTO `blogs` VALUES (85, '浅谈js中子页面父页面方法 变量相互调用', 'fuwenben963&lt;p&gt;&lt;strong&gt;(1）子页面调用父页面的方法或者变量：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;window.parent.方法()或者变量名 window.parent相当于定位到父页面 之后的操作和在父页面中写代码一样写&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;window.parent.aa();//调取aa函数\nwindow.parent.bb;//调取bb变量\n\n例如：想在子页面中得到id为aaa的文本框的值\n\nwindow.parent.$(&quot;#aaa&quot;).val();//这种写法的前提是引用了jquery \n\nwindow.parent.getElementById(&quot;aaa&quot;).value; //js的写法\n&lt;/pre&gt;&lt;p&gt;**（2）父页面调取子页面 **&lt;/p&gt;&lt;p&gt;主要是通过contentWindow定位到子页面&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;document.getElementById(&quot;childframe&quot;).contentWindow.childtest();\n//调取子页面中的childtest方法 js的写法\n\nvar childWindow = $(&quot;#addFrame&quot;)[0].contentWindow;//获取子窗体中的对象\nchildWindow.formSubmit();//调取子页面的formSubmit方法 jquery的写法\n//注释：其中 childframe和addFrame 都时iframe的id\n\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;fuwenben963', 1566641526591, 'liuwk', '浅谈js中子页面父页面方法 变量相互调用', '3', 24);
INSERT INTO `blogs` VALUES (88, '你有必要知道的 25 个 JavaScript 面试题', 'fuwenben963&lt;p&gt;1、使用 typeof bar === &quot;object&quot; 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？...&lt;/p&gt;&lt;p&gt;使用 typeof 的弊端是显而易见的(这种弊端同使用 instanceof)：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;let obj = {};\nlet arr = [];\n\nconsole.log(typeof obj === &#039;object&#039;);  //true\nconsole.log(typeof arr === &#039;object&#039;);  //true\nconsole.log(typeof null === &#039;object&#039;);  //true\n&lt;/pre&gt;&lt;p&gt;从上面的输出结果可知，typeof bar === &quot;object&quot; 并不能准确判断 bar 就是一个 Object。可以通过Object.prototype.toString.call(bar) === &quot;[object Object]&quot; 来避免这种弊端：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;let obj = {};\nlet arr = [];\n\nconsole.log(Object.prototype.toString.call(obj));  //[object Object]\nconsole.log(Object.prototype.toString.call(arr));  //[object Array]\nconsole.log(Object.prototype.toString.call(null));  //[object Null]\n&lt;/pre&gt;&lt;p&gt;而 [ ] === false 是返回 false 的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 2、下面的代码会在 console 输出神马？为什么？&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;  var a = b = 3;\n})();\n\nconsole.log(&quot;a defined? &quot; + (typeof a !== &#039;undefined&#039;));   \nconsole.log(&quot;b defined? &quot; + (typeof b !== &#039;undefined&#039;));\n这跟变量作用域有关，输出换成下面的：\n\nconsole.log(b); //3\nconsole,log(typeof a); //undefined\n拆解一下自执行函数中的变量赋值：\n\nb = 3;\nvar a = b;\n所以 b 成了全局变量，而 a 是自执行函数的一个局部变量。\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;3、下面的代码会在 console 输出神马？为什么？&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;var myObject = {\n    foo: &quot;bar&quot;,\n    func: function() {\n        var self = this;\n        console.log(&quot;outer func:  this.foo = &quot; + this.foo);\n        console.log(&quot;outer func:  self.foo = &quot; + self.foo);\n        (function() {\n            console.log(&quot;inner func:  this.foo = &quot; + this.foo);\n            console.log(&quot;inner func:  self.foo = &quot; + self.foo);\n        }());\n    }\n};\nmyObject.func();\n第一个和第二个的输出不难判断，在 ES6 之前，JavaScript 只有函数作用域，所以 func 中的 IIFE 有自己的独立作用域，并且它能访问到外部作用域中的 self，所以第三个输出会报错，因为 this 在可访问到的作用域内是 undefined，第四个输出是 bar。如果你知道闭包，也很容易解决的：\n\n(function(test) {\n            console.log(&quot;inner func:  this.foo = &quot; + test.foo);  //&#039;bar&#039;\n            console.log(&quot;inner func:  self.foo = &quot; + self.foo);\n}(self));\n如果对闭包不熟悉，可以戳此：从作用域链谈闭包\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;4、将 JavaScript 代码包含在一个函数块中有神马意思呢？为什么要这么做？&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\n换句话说，为什么要用立即执行函数表达式（Immediately-Invoked Function Expression）。\n\nIIFE 有两个比较经典的使用场景，一是类似于在循环中定时输出数据项，二是类似于 JQuery/Node 的插件和模块开发。\n\nfor(var i = 0; i &amp;lt; 5; i++) {\n    setTimeout(function() {\n        console.log(i);  \n    }, 1000);\n}\n上面的输出并不是你以为的0，1，2，3，4，而输出的全部是5，这时 IIFE 就能有用了：\n\nfor(var i = 0; i &amp;lt; 5; i++) {\n    (function(i) {\n      setTimeout(function() {\n        console.log(i);  \n      }, 1000);\n    })(i)\n}\n而在 JQuery/Node 的插件和模块开发中，为避免变量污染，也是一个大大的 IIFE：\n\n(function($) { \n        //代码\n } )(jQuery);\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;5、在严格模式(&#039;use strict&#039;)下进行 JavaScript 开发有神马好处？&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;\n消除代码运行的一些不安全之处，保证代码运行的安全；\n提高编译器效率，增加运行速度；\n为未来新版本的Javascript做好铺垫。\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;6、下面两个函数的返回值是一样的吗？为什么？&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;function foo1()\n{\n  return {\n      bar: &quot;hello&quot;\n  };\n}\n\nfunction foo2()\n{\n  return\n  {\n      bar: &quot;hello&quot;\n  };\n}\n在编程语言中，基本都是使用分号（;）将语句分隔开，这可以增加代码的可读性和整洁性。而在JS中，如若语句各占独立一行，通常可以省略语句间的分号（;），JS 解析器会根据能否正常编译来决定是否自动填充分号：\n\nvar test = 1 + \n2\nconsole.log(test);  //3\n在上述情况下，为了正确解析代码，就不会自动填充分号了，但是对于 return 、break、continue 等语句，如果后面紧跟换行，解析器一定会自动在后面填充分号(;)，所以上面的第二个函数就变成了这样：\n\nfunction foo2()\n{\n  return;\n  {\n      bar: &quot;hello&quot;\n  };\n}\n所以第二个函数是返回 undefined。\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;7、神马是 NaN，它的类型是神马？怎么测试一个值是否等于 NaN?&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;NaN 是 Not a Number 的缩写，JavaScript 的一种特殊数值，其类型是 Number，可以通过 isNaN(param)来判断一个值是否是 NaN：\n\nconsole.log(isNaN(NaN)); //true\nconsole.log(isNaN(23)); //false\nconsole.log(isNaN(&#039;ds&#039;)); //true\nconsole.log(isNaN(&#039;32131sdasd&#039;)); //true\nconsole.log(NaN === NaN); //false\nconsole.log(NaN === undefined); //false\nconsole.log(undefined === undefined); //false\nconsole.log(typeof NaN); //number\nconsole.log(Object.prototype.toString.call(NaN)); //[object Number]\nES6 中，isNaN() 成为了 Number 的静态方法：Number.isNaN().\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;8、解释一下下面代码的输出&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;console.log(0.1 + 0.2);   //0.30000000000000004\nconsole.log(0.1 + 0.2 == 0.3);  //false\nJavaScript 中的 number 类型就是浮点型，JavaScript 中的浮点数采用IEEE-754 格式的规定，这是一种二进制表示法，可以精确地表示分数，比如1/2，1/8，1/1024，每个浮点数占64位。但是，二进制浮点数表示法并不能精确的表示类似0.1这样 的简单的数字，会有舍入误差。\n\n由于采用二进制，JavaScript 也不能有限表示 1/10、1/2 等这样的分数。在二进制中，1/10(0.1)被表示为0.00110011001100110011…… 注意 0011 是无限重复的，这是舍入误差造成的，所以对于 0.1 + 0.2 这样的运算，操作数会先被转成二进制，然后再计算：\n\n0.1 =&amp;gt; 0.0001 1001 1001 1001…（无限循环）\n0.2 =&amp;gt; 0.0011 0011 0011 0011…（无限循环）\n双精度浮点数的小数部分最多支持 52 位，所以两者相加之后得到这么一串 0.0100110011001100110011001100110011001100...因浮点数小数位的限制而截断的二进制数字，这时候，再把它转换为十进制，就成了 0.30000000000000004。\n\n对于保证浮点数计算的正确性，有两种常见方式。\n\n一是先升幂再降幂：\n\nfunction add(num1, num2){\n  let r1, r2, m;\n  r1 = (&#039;&#039;+num1).split(&#039;.&#039;)[1].length;\n  r2 = (&#039;&#039;+num2).split(&#039;.&#039;)[1].length;\n\n  m = Math.pow(10,Math.max(r1,r2));\n  return (num1 * m + num2 * m) / m;\n}\nconsole.log(add(0.1,0.2));   //0.3\nconsole.log(add(0.15,0.2256)); //0.3756\n二是是使用内置的 toPrecision() 和 toFixed() 方法，注意，方法的返回值字符串。\n\nfunction add(x, y) {\n    return x.toPrecision() + y.toPrecision()\n}\nconsole.log(add(0.1,0.2));  //&quot;0.10.2&quot;\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;9、实现函数 isInteger(x) 来判断 x 是否是整数&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\n可以将 x 转换成10进制，判断和本身是不是相等即可：\n\nfunction isInteger(x) { \n    return parseInt(x, 10) === x; \n}\nES6 对数值进行了扩展，提供了静态方法 isInteger() 来判断参数是否是整数：\n\nNumber.isInteger(25) // true\nNumber.isInteger(25.0) // true\nNumber.isInteger(25.1) // false\nNumber.isInteger(&quot;15&quot;) // false\nNumber.isInteger(true) // false\nJavaScript能够准确表示的整数范围在 -2^53 到 2^53 之间（不含两个端点），超过这个范围，无法精确表示这个值。ES6 引入了Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限，并提供了 Number.isSafeInteger() 来判断整数是否是安全型整数。\n&lt;/pre&gt;&lt;p&gt;10、在下面的代码中，数字 1-4 会以什么顺序输出？为什么会这样输出？&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;(function() {\n    console.log(1); \n    setTimeout(function(){console.log(2)}, 1000); \n    setTimeout(function(){console.log(3)}, 0); \n    console.log(4);\n})();\n这个就不多解释了，主要是 JavaScript 的定时机制和时间循环，不要忘了，JavaScript 是单线程的。详解可以参考 从setTimeout谈JavaScript运行机制。\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;11、写一个少于 80 字符的函数，判断一个字符串是不是回文字符串&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;function isPalindrome(str) {\n    str = str.replace(/W/g, &#039;&#039;).toLowerCase();\n    return (str == str.split(&#039;&#039;).reverse().join(&#039;&#039;));\n}\n这个题我在 codewars 上碰到过，并收录了一些不错的解决方式，可以戳这里：Palindrome For Your Dome\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;12、写一个按照下面方式调用都能正常工作的 sum 方法&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;console.log(sum(2,3));   // Outputs 5\nconsole.log(sum(2)(3));  // Outputs 5\n针对这个题，可以判断参数个数来实现：\n\nfunction sum() {\n  var fir = arguments[0];\n  if(arguments.length === 2) {\n    return arguments[0] + arguments[1]\n  } else {\n    return function(sec) {\n       return fir + sec;\n    }\n  }\n\n}\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;13、根据下面的代码片段回答后面的问题&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;for (var i = 0; i &amp;lt; 5; i++) {\n  var btn = document.createElement(&#039;button&#039;);\n  btn.appendChild(document.createTextNode(&#039;Button &#039; + i));\n  btn.addEventListener(&#039;click&#039;, function(){ console.log(i); });\n  document.body.appendChild(btn);\n}\n1、点击 Button 4，会在控制台输出什么？\n2、给出一种符合预期的实现方式\n\n1、点击5个按钮中的任意一个，都是输出5\n2、参考 IIFE。\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;14、下面的代码会输出什么？为什么？&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;var arr1 = &quot;john&quot;.split(&#039;&#039;); j o h n\nvar arr2 = arr1.reverse(); n h o j\nvar arr3 = &quot;jones&quot;.split(&#039;&#039;); j o n e s\narr2.push(arr3);\nconsole.log(&quot;array 1: length=&quot; + arr1.length + &quot; last=&quot; + arr1.slice(-1));\nconsole.log(&quot;array 2: length=&quot; + arr2.length + &quot; last=&quot; + arr2.slice(-1));\n会输出什么呢？你运行下就知道了，可能会在你的意料之外。\n\nMDN 上对于 reverse() 的描述是酱紫的：\n\nDescription\nThe reverse method transposes the elements of the calling array object in place, mutating the array, and returning a reference to the array.\nreverse() 会改变数组本身，并返回原数组的引用。\n\nslice 的用法请参考：slice\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;15、下面的代码会输出什么？为什么？&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;console.log(1 +  &quot;2&quot; + &quot;2&quot;);\nconsole.log(1 +  +&quot;2&quot; + &quot;2&quot;);\nconsole.log(1 +  -&quot;1&quot; + &quot;2&quot;);\nconsole.log(+&quot;1&quot; +  &quot;1&quot; + &quot;2&quot;);\nconsole.log( &quot;A&quot; - &quot;B&quot; + &quot;2&quot;);\nconsole.log( &quot;A&quot; - &quot;B&quot; + 2);\n输出什么，自己去运行吧，需要注意三个点：\n多个数字和数字字符串混合运算时，跟操作数的位置有关\nconsole.log(2 + 1 + &#039;3&#039;); / /‘33’\nconsole.log(&#039;3&#039; + 2 + 1); //&#039;321&#039;\n数字字符串之前存在数字中的正负号(+/-)时，会被转换成数字\nconsole.log(typeof &#039;3&#039;);   // string\nconsole.log(typeof +&#039;3&#039;);  //number\n同样，可以在数字前添加 &#039;&#039;，将数字转为字符串\nconsole.log(typeof 3);   // number\nconsole.log(typeof (&#039;&#039;+3));  //string\n对于运算结果不能转换成数字的，将返回 NaN\nconsole.log(&#039;a&#039; * &#039;sd&#039;);   //NaN\nconsole.log(&#039;A&#039; - &#039;B&#039;);  // NaN\n这张图是运算转换的规则\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;16、如果 list 很大，下面的这段递归代码会造成堆栈溢出。如果在不改变递归模式的前提下修善这段代码？&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;var list = readHugeList();\n\nvar nextListItem = function() {\n    var item = list.pop();\n\n    if (item) {\n        // process the list item...\n        nextListItem();\n    }\n};\n原文上的解决方式是加个定时器：\n\nvar list = readHugeList();\n\nvar nextListItem = function() {\n    var item = list.pop();\n\n    if (item) {\n        // process the list item...\n        setTimeout( nextListItem, 0);\n    }\n};\n解决方式的原理请参考第10题。\n\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;17、什么是闭包？举例说明&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;可以参考此篇：从作用域链谈闭包\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;18、下面的代码会输出什么？为啥？&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;for (var i = 0; i &amp;lt; 5; i++) {\n  setTimeout(function() { console.log(i); }, i * 1000 );\n}\n请往前面翻，参考第4题，解决方式已经在上面了\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;19、解释下列代码的输出&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;console.log(&quot;0 || 1 = &quot;+(0 || 1));\nconsole.log(&quot;1 || 2 = &quot;+(1 || 2));\nconsole.log(&quot;0 &amp;amp;&amp;amp; 1 = &quot;+(0 &amp;amp;&amp;amp; 1));\nconsole.log(&quot;1 &amp;amp;&amp;amp; 2 = &quot;+(1 &amp;amp;&amp;amp; 2));\n逻辑与和逻辑或运算符会返回一个值，并且二者都是短路运算符：\n\n逻辑与返回第一个是 false 的操作数 或者 最后一个是 true的操作数\nconsole.log(1 &amp;amp;&amp;amp; 2 &amp;amp;&amp;amp; 0);  //0\nconsole.log(1 &amp;amp;&amp;amp; 0 &amp;amp;&amp;amp; 1);  //0\nconsole.log(1 &amp;amp;&amp;amp; 2 &amp;amp;&amp;amp; 3);  //3\n如果某个操作数为 false，则该操作数之后的操作数都不会被计算\n\n逻辑或返回第一个是 true 的操作数 或者 最后一个是 false的操作数\nconsole.log(1 || 2 || 0); //1\nconsole.log(0 || 2 || 1); //2\nconsole.log(0 || 0 || false); //false\n如果某个操作数为 true，则该操作数之后的操作数都不会被计算\n\n如果逻辑与和逻辑或作混合运算，则逻辑与的优先级高：\n\nconsole.log(1 &amp;amp;&amp;amp; 2 || 0); //2\nconsole.log(0 || 2 &amp;amp;&amp;amp; 1); //1\nconsole.log(0 &amp;amp;&amp;amp; 2 || 1); //1\n在 JavaScript，常见的 false 值：\n\n0, &#039;0&#039;, +0, -0, false, &#039;&#039;,null,undefined,null,NaN\n要注意空数组([])和空对象({}):\n\nconsole.log([] == false) //true\nconsole.log({} == false) //false\nconsole.log(Boolean([])) //true\nconsole.log(Boolean({})) //true\n所以在 if 中，[] 和 {} 都表现为 true：\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;20、解释下面代码的输出&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;console.log(false == &#039;0&#039;)\nconsole.log(false === &#039;0&#039;)\n请参考前面第14题运算符转换规则的图。\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;21、解释下面代码的输出&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;var a={},\n    b={key:&#039;b&#039;},\n    c={key:&#039;c&#039;};\n\na[b]=123;\na[c]=456;\n\nconsole.log(a[b]);\n输出是 456，参考原文的解释：\n\nThe reason for this is as follows: When setting an object property, JavaScript will implicitly stringify the parameter value. In this case, since b and c are both objects, they will both be converted to &quot;[object Object]&quot;. As a result, a[b] anda[c] are both equivalent to a[&quot;[object Object]&quot;] and can be used interchangeably. Therefore, setting or referencing a[c] is precisely the same as setting or referencing a[b].\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;22、解释下面代码的输出&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;console.log((function f(n){return ((n &amp;gt; 1) ? n * f(n-1) : n)})(10));\n结果是10的阶乘。这是一个递归调用，为了简化，我初始化 n=5，则调用链和返回链如下：\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;23、解释下面代码的输出&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;(function(x) {\n    return (function(y) {\n        console.log(x);\n    })(2)\n})(1);\n输出1，闭包能够访问外部作用域的变量或参数。\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;24、解释下面代码的输出，并修复存在的问题&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;var hero = {\n    _name: &#039;John Doe&#039;,\n    getSecretIdentity: function (){\n        return this._name;\n    }\n};\n\nvar stoleSecretIdentity = hero.getSecretIdentity;\n\nconsole.log(stoleSecretIdentity());\nconsole.log(hero.getSecretIdentity());\n将 getSecretIdentity 赋给 stoleSecretIdentity，等价于定义了 stoleSecretIdentity 函数：\n\nvar stoleSecretIdentity =  function (){\n        return this._name;\n}\nstoleSecretIdentity 的上下文是全局环境，所以第一个输出 undefined。若要输出 John Doe，则要通过 call 、apply 和 bind 等方式改变 stoleSecretIdentity 的this 指向(hero)。\n\n第二个是调用对象的方法，输出 John Doe。\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;25、给你一个 DOM 元素，创建一个能访问该元素所有子元素的函数，并且要将每个子元素传递给指定的回调函数。&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;函数接受两个参数：\n\nDOM\n指定的回调函数\n原文利用 深度优先搜索(Depth-First-Search) 给了一个实现：\n\nfunction Traverse(p_element,p_callback) {\n   p_callback(p_element);\n   var list = p_element.children;\n   for (var i = 0; i &amp;lt; list.length; i++) {\n       Traverse(list[i],p_callback);  // recursive call\n   }\n}\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;fuwenben963', 1566642258561, 'liuwk', '你有必要知道的 25 个 JavaScript 面试题', '3', 14);
INSERT INTO `blogs` VALUES (93, '富文本vue-quill-editor整合七牛云上传图片', 'fuwenben963&quot;&lt;p&gt;1.概述 实现前提:&lt;/p&gt;&lt;p&gt;Element UI:上传使用的是Element 的el-upload组件, 可以参考&amp;nbsp;&lt;a href=&quot;http://element.eleme.io/#/zh-CN/component/upload&quot; target=&quot;_blank&quot; style=&quot;color: rgb(0, 108, 255);&quot;&gt;http://element.eleme.io/#/zh-CN/component/upload&lt;/a&gt;&amp;nbsp;quill-editor:富文本处理，可以参考文档&amp;nbsp;&lt;a href=&quot;https://surmon-china.github.io/vue-quill-editor/&quot; target=&quot;_blank&quot; style=&quot;color: rgb(0, 108, 255);&quot;&gt;https://surmon-china.github.io/vue-quill-editor/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;参考文章大神的文章&amp;nbsp;&lt;a href=&quot;https://github.com/NextBoy/skill/issues/2&quot; target=&quot;_blank&quot; style=&quot;color: rgb(0, 108, 255);&quot;&gt;https://github.com/NextBoy/skill/issues/2&lt;/a&gt;&amp;nbsp;这里主要讲解的是如何使用Element和quill-editor还有七牛云整合的思路&lt;/p&gt;&lt;p&gt;实现思路： 根据大神的文章，大概思路如下：&lt;/p&gt;&lt;p&gt;1.先用el-upload组件实现和七牛云的上传。 2.隐藏掉el-upload组件。 3.处理点击富文本框的图片的按钮的时候，调用el-upload的上传。 4.上传成功后，拼接好图片的地址，按照光标的为止插入到富文本中 目标:将上面的部分封装成组件，提供给每个页面方面的使用&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1.实现代码&lt;/strong&gt;&amp;nbsp;&lt;strong&gt;1.1 组件定义&lt;/strong&gt;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;&amp;lt;!-- \n基于quill-editor的整合七牛云上传的自定义组件\nelemntUI文档地址 http://element.eleme.io/#/zh-CN/component/tag\nquill-editor 文档地址 https://surmon-china.github.io/vue-quill-editor/\nquill-editor整合七牛云上传https://github.com/NextBoy/skill/issues/2\n--&amp;gt;\n \n&amp;lt;template&amp;gt;\n   &amp;lt;div id=&#039;quillEditorQiniu&#039;&amp;gt;\n       &amp;lt;!-- 基于elementUi的上传组件 el-upload begin--&amp;gt;\n       &amp;lt;el-upload\n            class=&quot;avatar-uploader&quot;\n            :action=&quot;uploadUrl&quot;\n            :accept=&quot;&#039;image/*&#039;&quot;\n            :data=&quot;qiniuForm&quot;\n            :show-file-list=&quot;false&quot;\n            :on-success=&quot;uploadEditorSuccess&quot;\n            :on-error=&quot;uploadEditorError&quot;\n            :before-upload=&quot;beforeEditorUpload&quot;&amp;gt;\n        &amp;lt;/el-upload&amp;gt;\n        &amp;lt;!-- 基于elementUi的上传组件 el-upload end--&amp;gt;\n        &amp;lt;quill-editor  class=&quot;editor&quot;  v-model=&quot;content&quot; ref=&quot;customQuillEditor&quot; :options=&quot;editorOption&quot; &amp;gt;\n        &amp;lt;/quill-editor&amp;gt;\n   &amp;lt;/div&amp;gt;\n&amp;lt;/template&amp;gt;\n \n&amp;lt;script&amp;gt;\nimport { quillEditor } from &#039;vue-quill-editor&#039;\n \n \n//自定义编辑器的工作条\nconst toolbarOptions = [\n        [&#039;bold&#039;, &#039;italic&#039;, &#039;underline&#039;, &#039;strike&#039;],        // toggled buttons\n        [&#039;blockquote&#039;, &#039;code-block&#039;],\n \n        [{&#039;header&#039;: 1}, {&#039;header&#039;: 2}],               // custom button values\n        [{&#039;list&#039;: &#039;ordered&#039;}, {&#039;list&#039;: &#039;bullet&#039;}],\n        [{&#039;script&#039;: &#039;sub&#039;}, {&#039;script&#039;: &#039;super&#039;}],      // superscript/subscript\n        [{&#039;indent&#039;: &#039;-1&#039;}, {&#039;indent&#039;: &#039;+1&#039;}],          // outdent/indent\n        [{&#039;direction&#039;: &#039;rtl&#039;}],                         // text direction\n \n        [{&#039;size&#039;: [&#039;small&#039;, false, &#039;large&#039;, &#039;huge&#039;]}],  // custom dropdown\n        [{&#039;header&#039;: [1, 2, 3, 4, 5, 6, false]}],\n \n        [{&#039;color&#039;: []}, {&#039;background&#039;: []}],          // dropdown with defaults from theme\n        [{&#039;font&#039;: []}],\n        [{&#039;align&#039;: []}],\n        [&#039;link&#039;, &#039;image&#039;, &#039;video&#039;],\n        [&#039;clean&#039;]                                         // remove formatting button\n    ];\nexport default {\n    data(){\n        return {\n           quillUpdateImg:false,\n           content:&#039;&#039;,\n           editorOption:{\n                  placeholder:&#039;请填写车辆详情信息&#039;,\n                  modules: {\n                        toolbar: {\n                            container: toolbarOptions,  // 工具栏\n                            handlers: {\n                                &#039;image&#039;: function (value) {\n                                    if (value) {\n                                        document.querySelector(&#039;#quillEditorQiniu .avatar-uploader input&#039;).click()\n                                    } else {\n                                        this.quill.format(&#039;image&#039;, false);\n                                    }\n                                }\n                            }\n                        }\n                 }\n            },\n            qiniuForm:{\n                &#039;key&#039;: &#039;&#039;,\n                &#039;token&#039;: &#039;&#039;,\n                &#039;domain&#039;:&#039;&#039;\n            },\n        }\n    },\n    props:{\n        token:String, //七牛云上传的token,类型为String\n        domain:String, //七牛云上传的域地址,类型为String\n        uploadUrl:String  //从七牛云上拿到自己的上传地址,类型为String\n    },\n    methods:{\n        //上传图片之前\n        beforeEditorUpload(res, file){\n \n            //显示上传动画\n            this.quillUpdateImg = true;\n        },\n \n        // 上传图片成功\n        uploadEditorSuccess(res, file) {\n \n            //拼接出上传的图片在服务器的完整地址\n            let imgUrl = this.qiniuForm.domain+ res.key;\n \n            //重置上传文件key，为下次上传做好准备\n            this.qiniuForm.key =  new Date().getTime()+&quot;&quot;+Math.floor(Math.random()*1000);\n \n            // 获取富文本组件实例\n            let quill = this.$refs.customQuillEditor.quill;\n \n           // 获取光标所在位置\n            let length = quill.getSelection().index;\n \n            // 插入图片  res.info为服务器返回的图片地址\n            quill.insertEmbed(length, &#039;image&#039;, imgUrl)\n \n            // 调整光标到最后\n            quill.setSelection(length + 1)\n \n            //取消上传动画\n            this.quillUpdateImg = false;\n \n        },\n        \n        // 上传图片失败\n        uploadEditorError(res, file) {\n            //页面提示\n            Notification.error({\n                   message: &#039;上传图片失败&#039;\n            });\n \n            //取消上传动画\n            this.quillUpdateImg = false;\n        },\n \n        \n \n       \n    },\n    mounted () {\n        this.qiniuForm.key =  new Date().getTime()+&quot;&quot;+Math.floor(Math.random()*1000);\n        this.qiniuForm.token = this.token;\n        this.qiniuForm.domain = this.domain;\n    },\n    watch:{\n        content(newVal, oldVal) {\n          this.$emit(&#039;input&#039;, newVal);\n        }\n    }\n \n    \n \n}\n&amp;lt;/script&amp;gt;\n \n&amp;lt;style scoped&amp;gt;\n.editor{\n    min-height: 200px;\n    margin-bottom: 60px;\n}\n&amp;lt;/style&amp;gt;\n \n\n&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;1.2 组件的使用&lt;/strong&gt;&amp;nbsp;&lt;strong&gt;1.2.1 引入组件&lt;/strong&gt;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;import SquillEditorQiniu from &#039;@/components/quill-editor-qiniu.vue&#039;;\n\n&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;1.2.2 注册成组件&lt;/strong&gt;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt; components:{\n        SquillEditorQiniu //富文本框上传组件\n    }\n\n&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;1.2.3 放入组件&lt;/strong&gt;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;&amp;lt;squill-editor-qiniu :token=&#039;qiniuForm.token&#039; v-model=&quot;addForm.details&quot; :domain=&#039;qiniuForm.domain&#039; uploadUrl=&#039;http://upload.qiniup.com/&#039;&amp;gt;&amp;lt;/squill-editor-qiniu&amp;gt;\n\n&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;token:需要从后台获取，后台和七牛云请求得到&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;v-model: 你最后得到的文本的属性&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;domain: 七牛云的域，可以从七牛云获取到&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;uploadUrl: 上传地址，也是从七牛云获取&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1.2 实现效果&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们可以看到最终上传一个图片，里面html代码里的图片地址是我们七牛云上的地址&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(51, 51, 51);&quot;&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019041711043787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMTYwOTM=,size_16,color_FFFFFF,t_70&quot;&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190417110505661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMTYwOTM=,size_16,color_FFFFFF,t_70&quot;&gt;&lt;/span&gt;&lt;/p&gt;&quot;fuwenben963', 1566658320844, 'liuwk', '富文本vue-quill-editor整合七牛云上传图片', '3', 21);
INSERT INTO `blogs` VALUES (94, '前端 nginx 跨域访问配置', 'fuwenben963&quot;&lt;p&gt;1、首先下载nginx ：&amp;nbsp;&lt;a href=&quot;http://nginx.org/en/download.html&quot; target=&quot;_blank&quot; style=&quot;color: rgb(0, 108, 255);&quot;&gt;http://nginx.org/en/download.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;2、&lt;img src=&quot;https://img-blog.csdnimg.cn/20181214173849776.png&quot;&gt;一般选择 Stable version 稳定版&lt;/p&gt;&lt;p&gt;3、 下载后 解压 随意放在那个盘 我以前下载的&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;ql-font-monospace&quot; style=&quot;background-color: rgba(0, 0, 0, 0.06);&quot;&gt;nginx-1.12.0&lt;/code&gt;&lt;/p&gt;&lt;p&gt;版本&lt;/p&gt;&lt;p&gt;4、&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;ql-font-monospace&quot; style=&quot;background-color: rgba(0, 0, 0, 0.06);&quot;&gt;E:\nginx-1.12.0conf\nginx.conf&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;我这放在E盘 打开&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;ql-font-monospace&quot; style=&quot;background-color: rgba(0, 0, 0, 0.06);&quot;&gt;nginx.conf&lt;/code&gt;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;#user  nobody;\nworker_processes  1;\n\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n#pid        logs/nginx.pid;\n\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n\n#log_format  main  &#039;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#039;\n#                  &#039;$status $body_bytes_sent &quot;$http_referer&quot; &#039;\n#                  &#039;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#039;;\n\n#access_log  logs/access.log  main;\n\nsendfile        on;\n#tcp_nopush     on;\n\n#keepalive_timeout  0;\nkeepalive_timeout  65;\n\n#gzip  on;\n\nserver {\n    listen       80;    ##  随意改动  我这里不改\n    server_name  localhost;   ##\n\n    #charset utf-8;  //   ##改为 utf-8; \n\n    #access_log  logs/host.access.log  main;\n\n    location / {\n        root   html;    ##主页   可改为其他目录\n        index  index.html index.htm;   ## 主页目录入口\n    }\n\n\n    location /apis/{  ## 这个名称在后面请求的时候用到\n        proxy_pass  http://192.168.0.104/;  ##  我这是后台的接口地址\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ .php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ .php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache&#039;s document root\n    # concurs with nginx&#039;s one\n    #\n    #location ~ /.ht {\n    #    deny  all;\n    #}\n}\n\n\n# another virtual host using mix of IP-, name-, and port-based configuration\n#\n#server {\n#    listen       8000;\n#    listen       somename:8080;\n#    server_name  somename  alias  another.alias;\n\n#    location / {\n#        root   html;\n#        index  index.html index.htm;\n#    }\n#}\n\n\n# HTTPS server\n#\n#server {\n#    listen       443 ssl;\n#    server_name  localhost;\n\n#    ssl_certificate      cert.pem;\n#    ssl_certificate_key  cert.key;\n\n#    ssl_session_cache    shared:SSL:1m;\n#    ssl_session_timeout  5m;\n\n#    ssl_ciphers  HIGH:!aNULL:!MD5;\n#    ssl_prefer_server_ciphers  on;\n\n#    location / {\n#        root   html;\n#        index  index.html index.htm;\n#    }\n#} \n#   }\n\n&lt;/pre&gt;&lt;p&gt;保存&lt;/p&gt;&lt;p&gt;启动&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;ql-font-monospace&quot; style=&quot;background-color: rgba(0, 0, 0, 0.06);&quot;&gt;E:\nginx-1.12.0 下的 nginx.exe&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;然后浏览器打开&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;ql-font-monospace&quot; style=&quot;background-color: rgba(0, 0, 0, 0.06);&quot;&gt;localhost&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;这是前端的页面代码&lt;/strong&gt;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;\n&amp;lt;html&amp;gt;\n\n&amp;lt;head&amp;gt;\n    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;\n    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;\n&amp;lt;/head&amp;gt;\n&amp;lt;script type=&quot;text/javascript&quot; src=&quot;https://code.jquery.com/jquery-3.1.0.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;\n&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;\n    $(function() {\n        $.ajax({\n     		    //http://192.168.0.104/admin/employee/getTree  原来后台的接口\n            url: &quot;http://localhost/apis/admin/employee/getTree&quot;, //  这里直接改成    apis  会通过ngiux转为我们设置的接口\n             //url: &quot;apis/movie/in_theaters&quot;, //  或者改成这样\n            type: &quot;GET&quot;,\n            success: function (data) {\n                $(&quot;.text&quot;).html(JSON.stringify(data));\n            },\n            error: function (text) {\n                $(&quot;text&quot;).html(JSON.stringify(text))\n            }\n        });\n    });\n&amp;lt;/script&amp;gt;\n\n&amp;lt;body&amp;gt;\n&amp;lt;span class=&quot;text&quot;&amp;gt;&amp;lt;/span&amp;gt;\n&amp;lt;/body&amp;gt;\n\n&amp;lt;/html&amp;gt;\n\n&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;成功&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(51, 51, 51);&quot;&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/201812141750551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMTYwOTM=,size_16,color_FFFFFF,t_70&quot;&gt;&lt;/span&gt;&lt;/p&gt;&quot;fuwenben963', 1566742772736, 'liuwk', '前端 nginx 跨域访问配置', '3', 0);
INSERT INTO `blogs` VALUES (95, '前端怎样使用base64图片上传到七牛云', 'fuwenben963&quot;&lt;p&gt;先通过后端拿到 domain 和 token 值 其实就是后端通过 七牛仓库的一些配置 返为 domain 和 token&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;     let url = globalAjaxUrl + &#039;/admin/banner/getToken&#039;;  \n    pageCommon.getAjax(url, {}, function (res) {\n        localStorage.setItem(&#039;domain&#039;, res.result.domain);\n        localStorage.setItem(&#039;token&#039;, res.result.token);\n    });\n\n&lt;/pre&gt;&lt;p&gt;我这里保存到了localStorage中&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(51, 51, 51);&quot;&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181213162702251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMTYwOTM=,size_16,color_FFFFFF,t_70&quot;&gt;&lt;/span&gt;传入 base64 的值&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt; 	    getTokenUrl:function (base) {\n	        let src;\n	        let token = localStorage.getItem(&#039;token&#039;);  // 获取到localStorage的 token\n	        let pic = base.split(&quot;base64,&quot;)[1];  //七牛云需要接受的参数是  base64， 后面的值 所以我把它截取了\n	        let url = &#039;http://upload-z2.qiniup.com/putb64/-1&#039;;  //  我这个是华南地区的   要根据仓库选择url   这个是官方的  https://developer.qiniu.com/kodo/kb/1326/how-to-upload-photos-to-seven-niuyun-base64-code\n	        $.ajax({\n	            url: url,\n	            type: &#039;POST&#039;,\n	            async:false,  //  这里我使用  同步的方式是为了把  得到的 src 返回出去\n	            beforeSend (request) { // 请求之前设置请求头\n	                request.setRequestHeader(&#039;Content-Type&#039;, &#039;application/octet-stream&#039;);\n	                request.setRequestHeader(&#039;Authorization&#039;, &#039;UpToken &#039; + token)   // token服务端请求\n	            },\n	            data: pic,\n	            success: function (data) {\n	                let domain =  localStorage.getItem(&#039;domain&#039;);  \n	                src = &#039; http://&#039; + domain +&#039;/&#039;+ data.key;   // 拼接上 domain就可以得到图片的url链接\n	            }\n	        });\n	        return src;\n    }\n\n&lt;/pre&gt;&lt;p&gt;这里函数 返回的 src 就是一个图片路径了&lt;/p&gt;&quot;fuwenben963', 1566742906754, 'liuwk', '前端怎样使用base64图片上传到七牛云', '3', 58);
INSERT INTO `blogs` VALUES (96, '在Linux系统安装Nodejs 最简单步骤', 'fuwenben963&quot;&lt;p&gt;1、 去官网下载和自己系统匹配的文件：&lt;/p&gt;&lt;p&gt;英文网址：&lt;a href=&quot;https://nodejs.org/en/download/&quot; target=&quot;_blank&quot; style=&quot;color: rgb(0, 108, 255);&quot;&gt;https://nodejs.org/en/download/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;中文网址：&lt;a href=&quot;http://nodejs.cn/download/&quot; target=&quot;_blank&quot; style=&quot;color: rgb(0, 108, 255);&quot;&gt;http://nodejs.cn/download/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;通过 uname -a 命令查看到我的Linux系统位数是64位（备注：x86_64表示64位系统， i686 i386表示32位系统），如图&lt;img src=&quot;https://images2015.cnblogs.com/blog/625378/201703/625378-20170301104556454-1441797328.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;&lt;p&gt;故下载一下红色框中文件 ，版本为v6.10.0&lt;/p&gt;&lt;p&gt;、 下载下来的tar文件上传到服务器并且解压，然后通过建立软连接变为全局；&lt;/p&gt;&lt;p&gt;1）上传服务器可以是自己任意路径，目前我的放置路径为 cd /app/software/&lt;/p&gt;&lt;p&gt;2）解压上传（解压后的文件我这边将名字改为了nodejs，这个地方自己随意，只要在建立软连接的时候写正确就可以）&lt;/p&gt;&lt;p&gt;① tar -xvf node-v6.10.0-linux-x64.tar.xz&lt;/p&gt;&lt;p&gt;② mv node-v6.10.0-linux-x64 nodejs&lt;/p&gt;&lt;p&gt;③ 确认一下nodejs下bin目录是否有node 和npm文件，如果有执行软连接，如果没有重新下载执行上边步骤；&lt;/p&gt;&lt;p&gt;3）建立软连接，变为全局&lt;/p&gt;&lt;p&gt;① ln -s /app/software/nodejs/bin/npm /usr/local/bin/&lt;/p&gt;&lt;p&gt;② ln -s /app/software/nodejs/bin/node /usr/local/bin/ 4）最后一步检验nodejs是否已变为全局&lt;/p&gt;&lt;p&gt;在Linux命令行node -v 命令会显示nodejs版本，如图所示为大功告成&lt;/p&gt;&quot;fuwenben963', 1566742921003, 'liuwk', '在Linux系统安装Nodejs 最简单步骤', '3', 14);
INSERT INTO `blogs` VALUES (97, 'centOS6.8安装nginx', 'fuwenben963&quot;&lt;p&gt;1.安装nginx所需环境： yum install gcc yum install pcre-devel yum install zlib zlib-devel yum install openssl openssl-devel 或者一键安装：yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel&lt;/p&gt;&lt;p&gt;2.下载nginx压缩包： wget&amp;nbsp;&lt;a href=&quot;http://nginx.org/download/nginx-1.15.7.tar.gz&quot; target=&quot;_blank&quot; style=&quot;color: rgb(0, 108, 255);&quot;&gt;http://nginx.org/download/nginx-1.15.7.tar.gz&lt;/a&gt;&lt;/p&gt;&lt;p&gt;下载在当前目录&lt;/p&gt;&lt;p&gt;3.解压缩：tar -zxvf nginx-1.15.7.tar.gz&lt;/p&gt;&lt;p&gt;4.进入nginx-1.10.2目录：cd nginx-1.15.7&lt;/p&gt;&lt;ol&gt;&lt;li&gt;执行 ./configure&lt;/li&gt;&lt;li&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;执行make&lt;/li&gt;&lt;li&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;执行make install&lt;/li&gt;&lt;li&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;查找nginx安装目录：whereis nginx&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;9.进入niginx安装目录,默认在 cd /usr/local/nginx/sbin&lt;/p&gt;&lt;ol&gt;&lt;li&gt;执行 ./nginx&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;11.打开浏览器，输入ip地址，看到welcome to nginx！即安装成功&lt;/p&gt;&lt;p&gt;如不行 在 sbin目录下执行下面步骤&lt;/p&gt;&lt;p&gt;fuser -k 80/tcp 强制停止80端口&lt;/p&gt;&lt;p&gt;./nginx -s reload 重载 nginx&lt;/p&gt;&lt;p&gt;./nginx -t 启动&lt;/p&gt;&lt;p&gt;./nginx 启动&lt;/p&gt;&quot;fuwenben963', 1566742952322, 'liuwk', 'centOS6.8安装nginx', '3', 15);
INSERT INTO `blogs` VALUES (98, 'layui 表格的下拉选择', 'fuwenben963&quot;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;\n&amp;lt;html&amp;gt;\n&amp;lt;head&amp;gt;\n    &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;\n    &amp;lt;title&amp;gt;layui 模仿下拉框 &amp;lt;/title&amp;gt;\n    &amp;lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&amp;gt;\n    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&amp;gt;\n    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&amp;gt;\n    &amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../js/plugins/layui/css/layui.css&quot;/&amp;gt;\n    &amp;lt;style&amp;gt;\n        body, div, dl, dt, dd, ul, ol, li, h1, h2, h3, h4, h5, h6, pre, code, form, fieldset, legend, input, textarea, p, blockquote, th, td {\n            margin: 0;\n            padding: 0;\n            list-style: none;\n            border: none;\n        }\n\n        html, body {\n            position: relative;\n            background: #EDF0F5;\n            color: #505458;\n            font-family: &quot;微软雅黑&quot;;\n            font-size: 14px;\n        }\n\n        .layui-table thead tr {\n            background-color: #fff;\n        }\n\n        .laytable-cell-1-sel {\n            overflow: inherit;\n        }\n\n        .layui-table-cell span {\n            font-weight: bold;\n        }\n\n        .layui-table-body tbody tr {\n            height: 50px;\n        }\n\n        .selectDemo {\n            height: 30px;\n            border: 1px solid #e6e6e6;\n            border-radius: 4px;\n        }\n\n    &amp;lt;/style&amp;gt;\n&amp;lt;/head&amp;gt;\n&amp;lt;body&amp;gt;\n\n&amp;lt;table class=&quot;layui-hide&quot; id=&quot;test&quot;&amp;gt;&amp;lt;/table&amp;gt;\n\n\n&amp;lt;script type=&quot;text/html&quot; id=&quot;select&quot;&amp;gt;\n    &amp;lt;select lay-filter=&quot;selDome&quot; class=&quot;selectDemo&quot; data-id=&quot;{{d.id}}&quot; lay-ignore onchange=&quot;selectDemo(this)&quot;&amp;gt;\n        {{# layui.each(d.sel, function(index, item){ }}\n            &amp;lt;option value=&quot;{{item}}&quot;&amp;gt;{{item}}&amp;lt;/option&amp;gt;\n        {{# }); }}\n    &amp;lt;/select&amp;gt;\n&amp;lt;/script&amp;gt;\n&amp;lt;script src=&quot;../assets/scripts/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;\n&amp;lt;script src=&quot;../js/plugins/layui/layui.all.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/script&amp;gt;\n\n\n&amp;lt;script&amp;gt;\n\n\n    var table = layui.table\n        , form = layui.form;\n\n    table.render({\n        elem: &#039;#test&#039;\n        , url: &#039;index.json&#039;\n        , sort: false\n        , unresize: true\n        , skin: &#039;line&#039;\n        , cols: [[\n            {type: &#039;numbers&#039;}\n            , {field: &#039;id&#039;, title: &#039;ID&#039;, width: 100}\n            , {field: &#039;username&#039;, title: &#039;用户名&#039;, templet: &#039;#usernameTpl&#039;}\n            , {field: &#039;city&#039;, title: &#039;城市&#039;}\n            , {field: &#039;wealth&#039;, title: &#039;财富&#039;, minWidth: 120}\n            , {field: &#039;sel&#039;, title: &#039;下拉选择&#039;, width: 110, templet: &#039;#select&#039;}\n        ]]\n    });\n\n    function selectDemo(a) {\n        console.log($(a).attr(&#039;data-id&#039;));\n        console.log($(a).val());\n    }\n\n&amp;lt;/script&amp;gt;\n\n&amp;lt;/body&amp;gt;\n&amp;lt;/html&amp;gt;\n&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;lindex.json&lt;/strong&gt;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;{\n  &quot;code&quot;: 0,\n  &quot;count&quot;: 1000,\n  &quot;data&quot;: [\n    {\n      &quot;city&quot;: &quot;城市-0&quot;,\n      &quot;classify&quot;: &quot;作家&quot;,\n      &quot;experience&quot;: 255,\n      &quot;id&quot;: 10000,\n      &quot;logins&quot;: 24,\n      &quot;score&quot;: 57,\n      &quot;sex&quot;: &quot;女&quot;,\n      &quot;sign&quot;: &quot;签名-0&quot;,\n      &quot;username&quot;: &quot;user-0&quot;,\n      &quot;wealth&quot;: 82830700,\n      &quot;sel&quot;:[&quot;测试1&quot;,&quot;测试2&quot;,&quot;测试3&quot;,&quot;测试4&quot;]\n    },\n    {\n      &quot;city&quot;: &quot;城市-1&quot;,\n      &quot;classify&quot;: &quot;词人&quot;,\n      &quot;experience&quot;: 884,\n      &quot;id&quot;: 10001,\n      &quot;logins&quot;: 58,\n      &quot;score&quot;: 27,\n      &quot;sex&quot;: &quot;男&quot;,\n      &quot;sign&quot;: &quot;签名-1&quot;,\n      &quot;username&quot;: &quot;user-1&quot;,\n      &quot;wealth&quot;: 64928690,\n      &quot;sel&quot;:[&quot;测试1&quot;,&quot;测试2&quot;,&quot;测试3&quot;]\n    },\n    {\n      &quot;city&quot;: &quot;城市-2&quot;,\n      &quot;classify&quot;: &quot;码农&quot;,\n      &quot;experience&quot;: 884,\n      &quot;id&quot;: 10003,\n      &quot;logins&quot;: 58,\n      &quot;score&quot;: 27,\n      &quot;sex&quot;: &quot;女&quot;,\n      &quot;sign&quot;: &quot;签名-1&quot;,\n      &quot;username&quot;: &quot;user-1&quot;,\n      &quot;wealth&quot;: 64928690,\n      &quot;sel&quot;:[&quot;测试1&quot;,&quot;测试2&quot;,&quot;测试3&quot;]\n    },\n    {\n      &quot;city&quot;: &quot;城市-3&quot;,\n      &quot;classify&quot;: &quot;码农&quot;,\n      &quot;experience&quot;: 884,\n      &quot;id&quot;: 10004,\n      &quot;logins&quot;: 58,\n      &quot;score&quot;: 27,\n      &quot;sex&quot;: &quot;女&quot;,\n      &quot;sign&quot;: &quot;签名-1&quot;,\n      &quot;username&quot;: &quot;user-1&quot;,\n      &quot;wealth&quot;: 64928690,\n      &quot;sel&quot;:[&quot;测试1&quot;,&quot;测试2&quot;,&quot;测试3&quot;]\n    }\n  ],\n  &quot;msg&quot;: &quot;&quot;\n}\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&quot;fuwenben963', 1566742973311, 'liuwk', 'layui 表格的下拉选择', '3', 10);
INSERT INTO `blogs` VALUES (100, '详解Javascript中的Object对象', 'fuwenben963&quot;&lt;p&gt;Object是在javascript中一个被我们经常使用的类型，而且JS中的所有对象都是继承自Object对象的...&lt;/p&gt;&lt;p&gt;虽说我们平时只是简单地使用了Object对象来存储数据，并没有使用到太多其他功能，但是Object对象其实包含了很多很有用的属性和方法，尤其是ES5增加的方法，因此，本文将从最基本的介绍开始，详细说明了Object的常用方法和应用。&lt;/p&gt;&lt;h3&gt;基础介绍&lt;/h3&gt;&lt;h4&gt;创建对象&lt;/h4&gt;&lt;p&gt;首先我们都知道，对象就是一组相似数据和功能的集合，我们就是用它来模拟我们现实世界中的对象的。那在Javascript中，创建对象的方式通常有两种方式：构造函数和对象字面量。&lt;/p&gt;&lt;h5&gt;new构造函数法&lt;/h5&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar person = new Object();\nperson.name = &quot;狼狼的蓝胖子&quot;;\nperson.age = 25;\n&lt;/pre&gt;&lt;p&gt;这种方式使用new关键字，接着跟上Object构造函数，再来给对象实例动态添加上不同的属性。这种方式相对来说比较繁琐，一般推荐使用对象字面量来创建对象。&lt;/p&gt;&lt;h5&gt;对象字面量&lt;/h5&gt;&lt;p&gt;对象字面量很好理解，使用key/value的形式直接创建对象，简洁方便。&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar person = {\n    name: “狼狼的蓝胖子”,\n    age: 25\n};\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;这种方式直接通过花括号将对象的属性包起来，使用key/value的方式创建对象属性，每个属性之间用逗号隔开。&lt;/p&gt;&lt;p&gt;注意：如果是最后一个属性，后面就不要加逗号，因为在一些旧的浏览器下会报错。&lt;/p&gt;&lt;h4&gt;对象实例的属性和方法&lt;/h4&gt;&lt;p&gt;不管通过哪种方式创建了对象实例后，该实例都会拥有下面的属性和方法，下面将会一一说明。&lt;/p&gt;&lt;h5&gt;constructor属性&lt;/h5&gt;&lt;p&gt;constructor属性是保存当前对象的构造函数，前面的例子中，constructor保存的就是Object方法。&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar obj1 = new Object();\nobj1.id = &quot;obj1&quot;;\nvar obj2 = {\n    &quot;id&quot;: &quot;obj2&quot;\n};\n \nconsole.log(obj1.constructor);//function Object(){}\nconsole.log(obj2.constructor);//function Object(){}\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h5&gt;hasOwnProperty(propertyName)方法&lt;/h5&gt;&lt;p&gt;hasOwnProperty方法接收一个字符串参数，该参数表示属性名称，用来判断该属性是否在当前对象实例中，而不是在对象的原型链中。我们来看看下面这个例子：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar arr = [];        \nconsole.log(arr.hasOwnProperty(&quot;length&quot;));//true\nconsole.log(arr.hasOwnProperty(&quot;hasOwnProperty&quot;));//false\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;在这个例子中，首先通过定义了一个数组对象的实例arr，我们知道数组对象实际是通过原型链继承了Object对象，然后拥有自己的一些属性，我们通过hasOwnProperty方法判断length是arr自己的属性，而hasOwnProperty是在原型链上的属性。&lt;/p&gt;&lt;p&gt;hasOwnProperty方法可以和for..in结合起来获取对象自己的key。&lt;/p&gt;&lt;h5&gt;isPrototypeOf(Object)方法&lt;/h5&gt;&lt;p&gt;isPrototype方法接收一个对象，用来判断当前对象是否在传入的参数对象的原型链上，说起来有点抽象，我们来看看代码。&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nfunction MyObject() {}\nvar obj = new MyObject();\nconsole.log(Object.prototype.isPrototypeOf(obj));\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;我们知道MyObject是继承自Object对象的，而在JS中，继承是通过prototype来实现的，所以Object的prototype必定在MyObject对象实例的原型链上。&lt;/p&gt;&lt;h5&gt;propertyIsEnumerable(prototypeName)方法&lt;/h5&gt;&lt;p&gt;prototypeIsEnumerable用来判断给定的属性是否可以被for..in语句给枚举出来。看下面代码：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar obj = {\n    name: &quot;objName&quot;\n}  \nfor (var i in obj) {\n    console.log(i);\n}\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;执行这段代码输出字符串“name”，这就说明通过for…in语句可以得到obj的name这个属性，但是我们知道，obj的属性还有很多，比如constructor，比如hasOwnPrototype等等，但是它们没有被输出，说明这些属性不能被for…in给枚举出来，可以通过propertyIsEnumerable方法来得到。&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;1\nconsole.log(obj.propertyIsEnumerable(&quot;constructor&quot;));//false\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;判断“constructor”是否可以被枚举，输出false说明无法被枚举出来。&lt;/p&gt;&lt;h5&gt;toLocaleString()方法&lt;/h5&gt;&lt;p&gt;toLocalString方法返回对象的字符串表示，和代码的执行环境有关。&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar obj = {};\nconsole.log(obj.toLocaleString());//[object Object]  \n\nvar date = new Date();\nconsole.log(date.toLocaleString());//2016/2/28 下午1:39:27\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h5&gt;toString()方法&lt;/h5&gt;&lt;p&gt;toString用来返回对象的字符串表示。&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar obj = {};\nconsole.log(obj.toString());//[object Object]\n        \nvar date = new Date();\nconsole.log(date.toString());//Sun Feb 28 2016 13:40:36 GMT+0800 (中国标准时间)\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h5&gt;valueOf()方法&lt;/h5&gt;&lt;p&gt;valueOf方法返回对象的原始值，可能是字符串、数值或bool值等，看具体的对象。&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\n var obj = {\n    name: &quot;obj&quot;\n};\nconsole.log(obj.valueOf());//Object {name: &quot;obj&quot;}\n\nvar arr = [1];\nconsole.log(arr.valueOf());//[1]\n\nvar date = new Date();\nconsole.log(date.valueOf());//1456638436303\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;如代码所示，三个不同的对象实例调用valueOf返回不同的数据。&lt;/p&gt;&lt;h4&gt;属性的类型&lt;/h4&gt;&lt;p&gt;在Javascript中，属性有两种类型，分别是数据属性和访问器属性，我们来看看这两种属性具体是什么东西。&lt;/p&gt;&lt;h5&gt;数据属性&lt;/h5&gt;&lt;p&gt;数据属性我们可以理解为我们平时定义对象时赋予的属性，它可以进行读和写。但是，ES5中定义了一些特性，这些特性是用来描述属性的各种特征，特性是内部值，不能直接访问到。特性通过用两对方括号表示，比如[[Enumerable]]。属性的特性会有一些默认值，要修改特性的默认值，必须使用ES5定义的新方法Object.defineProperty方法来修改。&lt;/p&gt;&lt;p&gt;数据属性有4个描述其特征的特性，下面将依次说明每一个特性：&lt;/p&gt;&lt;p&gt;（1）[[Configurable]]：该特性表示是否可以通过delete操作符来删除属性，默认值是true。&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar obj = {};\nobj.name = &quot;myname&quot;;\n        \ndelete obj.name;\nconsole.log(obj.name);//undefined\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;这段代码很明显，通过delete删除了obj的name属性后，我们再访问name属性就访问不到了。&lt;/p&gt;&lt;p&gt;我们通过Object.defineProperty方法来修改[[Configurable]]特性。&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar obj = {};\nobj.name = &quot;myname&quot;;\nObject.defineProperty(obj, &quot;name&quot;, {\n    configurable: false\n})                \n\ndelete obj.name;\nconsole.log(obj.name);//myname\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;通过将configurable特性设置成false之后，delete就无法删除name属性了，如果在严格模式下，使用delete去删除就会报错。&lt;/p&gt;&lt;p&gt;（2）[[Enumerable]]：表示是否能够通过for…in语句来枚举出属性，默认是true&lt;/p&gt;&lt;p&gt;我们来看看前面的例子：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar obj = {\n    name: &quot;objName&quot;\n}  \nfor (var i in obj) {\n    console.log(i);//name\n}\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;这段代码只输出了name属性，我们来将constructor属性的[[Enumerable]]设置为true试试。&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\n var obj = {\n        name: &quot;objName&quot;\n}\nObject.defineProperty(obj, &quot;constructor&quot;, {\n    enumerable: true\n})\n\nfor (var i in obj) {\n    console.log(i);//name,constructor\n}\nconsole.log(obj.propertyIsEnumerable(&quot;constructor&quot;));//true\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;这段代码中，for…in循环得到了name和constructor两个属性，而通过propertyIsEnumerable方法来判断constructor也返回了true。&lt;/p&gt;&lt;p&gt;（3）[[Writable]]：表示属性值是否可以修改，默认为true&lt;/p&gt;&lt;p&gt;如果[[Writable]]被设置成false，尝试修改时将没有效果，在严格模式下会报错&lt;/p&gt;&lt;p&gt;（4）[[Value]]：表示属性的值，默认为undefined&lt;/p&gt;&lt;p&gt;我们通过一个简单的例子来看看这两个特性：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar obj = {\n    name: &quot;name&quot;\n};\nconsole.log(obj.name);//name        \n\nObject.defineProperty(obj, &quot;name&quot;, {\n    value: &quot;newValue&quot;,\n    writable: false\n})\nconsole.log(obj.name);//newValue\n\nobj.name = &quot;oldValue&quot;;\nconsole.log(obj.name);//newValue\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;我们首先定义了obj对象的name属性值为“name”，然后通过defineProperty方法来修改值，并且将其设置为不可修改的。接着我们再修改name属性的值，可以发现修改无效。&lt;/p&gt;&lt;p&gt;如果我们通过defineProperty来修改name属性的值，是否可以修改呢？答案是可以的：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nObject.defineProperty(obj, &quot;name&quot;, {\n    value: &quot;oldValue&quot;\n})\nconsole.log(obj.name); //oldValue\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h5&gt;访问器属性&lt;/h5&gt;&lt;p&gt;访问器属性有点类似于C#中的属性，和数据属性的区别在于，它没有数据属性的[[Writable]]和[[Value]]两个特性，而是拥有一对getter和setter函数。&lt;/p&gt;&lt;p&gt;[[Get]]：读取属性时调用的函数，默认是undefined&lt;/p&gt;&lt;p&gt;[[Set]]：设置属性时调用的函数，默认是undefined&lt;/p&gt;&lt;p&gt;getter和setter是一个很有用的东西，假设有两个属性，其中第二个属性值会随着第一个属性值的变化而变化。这种场景在我们平时的编码中起始是非常常见的。在之前的做法中，我们往往要去手动修改第二个属性的值，那现在我们就可以通过get和set函数来解决这个问题。看下面这个例子：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar person = {\n    age: 10\n}\n\nObject.defineProperty(person, &quot;type&quot;, {\n    get: function () {\n        if (person.age &amp;gt; 17) {\n            return &quot;成人&quot;;\n        }\n        return &quot;小孩&quot;;\n    }\n})\n\nconsole.log(person.type);//小孩\n\nperson.age = 18;\nconsole.log(person.type);//成人\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;通过修改age的值，type的值也会相应的修改，这样我们就不用再手动的去修改type的值了。&lt;/p&gt;&lt;p&gt;下面这种方式也是可以实现同样的效果：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar person = {\n    _age: 10,\n    type: &quot;小孩&quot;\n} \n\nObject.defineProperty(person, &quot;age&quot;, {\n    get: function () {\n        return this._age;\n    },\n    set: function (newValue) {\n        this._age = newValue;\n        this.type = newValue &amp;gt; 17 ? &quot;成人&quot; : &quot;小孩&quot;;\n    }\n})\nconsole.log(person.type);\n\nperson.age = 18;\nconsole.log(person.type);\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;关于访问器属性，有几点要注意：&lt;/p&gt;&lt;p&gt;1、严格模式下，必须同时设置get和set&lt;/p&gt;&lt;p&gt;2、非严格模式下，可以只设置其中一个，如果只设置get，则属性是只读的，如果只设置set，属性则无法读取&lt;/p&gt;&lt;p&gt;3、Object.defineProperty是ES5中的新方法，IE9（IE8部分实现，只有dom对象才支持）以下浏览器不支持，一些旧的浏览器可以通过非标准方法&lt;strong&gt;defineGetter&lt;/strong&gt;()和&lt;strong&gt;defineSetter&lt;/strong&gt;()来设置，这里就不说明了，有兴趣的同学可以查找相关资料。&lt;/p&gt;&lt;h5&gt;特性操作的相关方法&lt;/h5&gt;&lt;p&gt;ES5提供了一些读取或操作属性特性的方法，前面用到的Object.defineProperty就是其中之一。我总结了一些比较常用的方法如下：&lt;/p&gt;&lt;p&gt;（1）Object.defineProperty&lt;/p&gt;&lt;p&gt;定义一个对象的属性，这个方法前面我们已经用到多次，简单说说其用法。&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nObject.defineProperty(obj,propName,descriptor);\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;defineProperty有点类似于定于在Object上的静态方法，通过Object直接调用，它接收3个参数：&lt;/p&gt;&lt;p&gt;obj：需要定义属性的对象&lt;/p&gt;&lt;p&gt;propNane：需要被定义的属性名称&lt;/p&gt;&lt;p&gt;defineProperty：属性描述符，包含一些属性的特性定义&lt;/p&gt;&lt;p&gt;例子如下：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar obj = {};\nObject.defineProperty(obj, &quot;name&quot;, {\n    value: &quot;name&quot;,\n    configurable: true,\n    writable: true,\n    enumerable: true\n});\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;（2）Object.defineProperties&lt;/p&gt;&lt;p&gt;和defineProperty类似，是用来定义对象属性的，不同的是它可以用来同时定义多个属性，我们通过命名也可以看出来，用法如下：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar obj = {};\nObject.defineProperty(obj, {\n    &quot;name&quot;: {\n        value: &quot;name&quot;,\n        configurable: true,\n        writable: true,\n        enumerable: true\n    },\n    &quot;age&quot;: {\n        value: 20 \n    }\n});\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;（3）Object.getOwnPropertyDescriptor&lt;/p&gt;&lt;p&gt;ES5中还提供了一个读取特性值的方法，该方法接收对象及其属性名作为两个参数，返回一个对象，根据属性类型的不同，返回对象会包含不同的值。&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar person = {\n    _age: 10,\n    type: &quot;小孩&quot;\n}\nObject.defineProperty(person, &quot;age&quot;, {\n    get: function () {\n        return this._age;\n    },\n    set: function (newValue) {\n        this._age = newValue;\n        this.type = newValue &amp;gt; 17 ? &quot;成人&quot; : &quot;小孩&quot;;\n    }\n})\n\nconsole.log(Object.getOwnPropertyDescriptor(person, &quot;type&quot;));//Object {value: &quot;成人&quot;, writable: true, enumerable: true, configurable: true}\nconsole.log(Object.getOwnPropertyDescriptor(person, &quot;age&quot;)); //Object {enumerable: false, configurable: false, get: function(),set: function ()}\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h3&gt;Object的方法&lt;/h3&gt;&lt;p&gt;在ES5中，Object对象上新增了一批方法，这些方法可以直接通过Object进行访问，前面用到的defineProperty就是新增的方法之一。除此之外还有很多方法，我将其总结归纳如下：&lt;/p&gt;&lt;h4&gt;对象创建型方法&lt;/h4&gt;&lt;h5&gt;Object.create(proto, [propertiesObject])&lt;/h5&gt;&lt;p&gt;在前面我们提到，创建一个对象有两种方法：构造函数和对象字面量。&lt;/p&gt;&lt;p&gt;这两种方法有一个缺点就是：如果要创建多个对象，写起来很繁琐，所以后来就有了一种创建自定义构造函数的方法来创建对象，如下所示：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nfunction Person(name, age) {\n    this.name = name;\n    this.age = age;\n}\n\nvar person = new Person(&quot;Jack&quot;, 15);\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;这种方式可以很方便的创建多个同样的对象，也是目前比较常用的方法。&lt;/p&gt;&lt;p&gt;ES5提供的Object.create方法也是一个创建对象的方法，这个方法允许为创建的对象选择原型对象，不需要定义一个构造函数。用法如下：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar obj = Object.create(Object.prototype, { \n    name: {\n        value: &quot;Jack&quot;\n    }\n})\nconsole.log(obj.name);//Jack\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;这个方法接收的第一个参数作为被创建对象的原型，第二个参数是对象的属性。注意：在这个例子中，name属性是无法被修改的，因为它没有设置writable特性，默认则为false。&lt;/p&gt;&lt;p&gt;个人看法：Object.create这种创建对象的方式略显繁琐，除非是需要修改属性的特性，否则不建议使用这种方式创建对象。&lt;/p&gt;&lt;h4&gt;属性获取型方法&lt;/h4&gt;&lt;h5&gt;Object.keys&lt;/h5&gt;&lt;p&gt;Object.keys是用来获取给定对象的所有可枚举的自身属性的属性名，它返回一个数组。&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nfunction Parent() {\n    this.lastName = &quot;Black&quot;\n}\nfunction Child(firstName) {\n    this.firstName = firstName;\n}\nChild.prototype = new Parent();\n\nvar son = new Child(&quot;Jack&quot;);\nconsole.log(Object.keys(son));//[&quot;firstName&quot;]\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;代码中返回了firstName，并没有返回从prototype继承而来的lastName和不可枚举的相关属性。&lt;/p&gt;&lt;p&gt;在一些旧的浏览器中，我们可以使用hasOwnProperty和for…in来达到类似的效果。&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nObject.keys = Object.keys ||\n    function (obj) {\n        var keys = [];\n        for (var key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                keys.push(key);\n            }\n        }\n        return keys;\n    }\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h5&gt;Object.getOwnPropertyNames()&lt;/h5&gt;&lt;p&gt;getOwnPropertyNames用来获取对象自身的所有属性，包括可枚举和不可枚举的所有属性，如下所示：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nfunction Parent() {\n    this.lastName = &quot;Black&quot;\n}\nfunction Child(firstName) {\n    this.firstName = firstName;\n}\nChild.prototype = new Parent();\n\nvar son = new Child(&quot;Jack&quot;);\nObject.defineProperty(son, &quot;age&quot;, {\n    enumerable: false\n})\nconsole.log(Object.keys(son));//[&quot;firstName&quot;]  \nconsole.log(Object.getOwnPropertyNames(son));//[&quot;firstName&quot;, &quot;age&quot;]\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;我们定义给son对象定义了一个不可枚举的属性age，然后通过keys和getOwnPropertyNames两个方法来获取属性列表，能明显看出了两者区别。&lt;/p&gt;&lt;h4&gt;属性特性型方法&lt;/h4&gt;&lt;p&gt;这个主要是前面提到的三个方法：defineProperty，defineProperties和getOwnPropertyDescriptor三个方法&lt;/p&gt;&lt;h4&gt;对象限制型方法&lt;/h4&gt;&lt;p&gt;ES5中提供了一系列限制对象被修改的方法，用来防止被某些对象被无意间修改导致的错误。每种限制类型包含一个判断方法和一个设置方法。&lt;/p&gt;&lt;h5&gt;阻止对象扩展&lt;/h5&gt;&lt;p&gt;Object.preventExtensions()用来限制对象的扩展，设置之后，对象将无法添加新属性，用法如下：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nObject.preventExtensions(obj);\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;该方法接收一个要被设置成无法扩展的对象作为参数，需要注意两点：&lt;/p&gt;&lt;p&gt;1、对象的属性不可用扩展，但是已存在的属性可以被删除&lt;/p&gt;&lt;p&gt;2、无法添加新属性指的是无法在自身上添加属性，如果是在对象的原型上，还是可以添加属性的。&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nfunction Person(name) {\n    this.name = name;\n}\nvar person = new Person(&quot;Jack&quot;);\nObject.preventExtensions(person);\n\ndelete person.name;\nconsole.log(person.name);//undefined\n\nPerson.prototype.age = 15;\nconsole.log(person.age);//15\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;Object.isExtensible方法用来判断一个对象是否可扩展，默认情况是true&lt;/p&gt;&lt;h5&gt;将对象密封&lt;/h5&gt;&lt;p&gt;Object.seal可以密封一个对象并返回被密封的对象。&lt;/p&gt;&lt;p&gt;密封对象无法添加或删除已有属性，也无法修改属性的enumerable，writable，configurable，但是可以修改属性值。&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nfunction Person(name) {\n    this.name = name;\n}\nvar person = new Person(&quot;Jack&quot;);\nObject.seal(person);\ndelete person.name;\nconsole.log(person.name);//Jack\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;将对象密封后，使用delete删除对象属性，还是可以访问得到属性。&lt;/p&gt;&lt;p&gt;通过Object.isSealed可以用来判断一个对象是否被密封了。&lt;/p&gt;&lt;h5&gt;冻结对象&lt;/h5&gt;&lt;p&gt;Object.freeze方法用来冻结一个对象，被冻结的对象将无法添加，修改，删除属性值，也无法修改属性的特性值，即这个对象无法被修改。&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nfunction Person(name) {\n    this.name = name;\n}\nvar person = new Person(&quot;Jack&quot;);\nObject.freeze(person);\n\ndelete person.name;\nconsole.log(person.name);//Jack\n\nPerson.prototype.age = 15;\nconsole.log(person.age);//15\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;分析上面的代码我们可以发现，被冻结的对象无法删除自身的属性，但是通过其原型对象还是可以新增属性的。&lt;/p&gt;&lt;p&gt;通过Object.isFrozen可以用来判断一个对象是否被冻结了。&lt;/p&gt;&lt;p&gt;可以发现：这三个限制对象的方法的限制程度是依次上升的。&lt;/p&gt;&lt;h3&gt;总结&lt;/h3&gt;&lt;p&gt;Object虽说是一个我们平时开发中最经常用到的对象，但是它的很多功能还没有被我们挖掘出来。本文首先介绍了Object的基本使用，接着介绍了一些比较少使用到的属性特性，最后分析了一些比较常用的方法，尤其是ES5中提供的新方法。欢迎大家交流！！&lt;/p&gt;&quot;fuwenben963', 1566743057368, 'liuwk', '详解Javascript中的Object对象', '3', 19);
INSERT INTO `blogs` VALUES (101, '详解Javascript中的Array对象', 'fuwenben963&quot;&lt;p&gt;在这一篇文章中，我们来说说Array对象。Array对象可以说是除Object对象之外用得最频繁的一个对象了...&lt;/p&gt;&lt;p&gt;下面我们来详细说说Array这个对象。&lt;/p&gt;&lt;h3&gt;基础介绍&lt;/h3&gt;&lt;h4&gt;创建数组&lt;/h4&gt;&lt;p&gt;和Object对象一样，创建Array也有2种方式：构造函数、字面量法。&lt;/p&gt;&lt;h5&gt;构造函数创建&lt;/h5&gt;&lt;p&gt;使用构造函数的方式可以通过new关键字来声明，如下所示：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar arr = new Array();\nconsole.log(arr);//[]\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;当然也可以不通过new关键字来声明：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar arr = Array();\nconsole.log(arr);  //[]\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;如果知道数组元素的个数，也可以直接传入数字表示元素个数：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar arr2 = new Array(5);\nconsole.log(arr2.length);  //5\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;也可以直接传入数组元素：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar arr3 = new Array(5, &quot;aa&quot;, &quot;bb&quot;);\nconsole.log(arr3);  //[5, &quot;aa&quot;, &quot;bb&quot;]\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h5&gt;字面量法创建&lt;/h5&gt;&lt;p&gt;通过字面量创建数组非常简单，推荐这种方式去创建数组：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar arr = [];\nconsole.log(arr);//[]\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;如果数组有一些初始值，可以直接写上去：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar arr2 = [5, &quot;aa&quot;, &quot;bb&quot;];\nconsole.log(arr2);  //[5, &quot;aa&quot;, &quot;bb&quot;]\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h4&gt;数组长度&lt;/h4&gt;&lt;p&gt;我们都知道要访问数组元素的个数很简单，直接通过length属性来获取到。&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar arr = [2, 3, 4, 5];\nconsole.log(arr.length);  //4\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;但是和其他语言不同的是，在JS中，length属性是可以被设置的。&lt;/p&gt;&lt;p&gt;假设我们要清空一个数组，我们可以直接将length设置成0：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\narr.length = 0;\nconsole.log(arr); //[]\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;可以看到，arr数组的元素被清空的&lt;/p&gt;&lt;p&gt;如果我们设置成负数会怎么样呢：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\narr.length = -1;//Uncaught RangeError: Invalid array length\nconsole.log(arr);\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;很明显，length是不允许被设置成负数的。&lt;/p&gt;&lt;p&gt;通过设置length属性，我们可以删除元素，比如：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar arr = [2, 3, 4, 5];\nconsole.log(arr);//[2, 3, 4, 5]\narr.length = 2;\nconsole.log(arr);[2, 3]\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;将length属性设置成比原来小的数值，后面的元素就会被移除掉。&lt;/p&gt;&lt;p&gt;如果将length设置成比原来大的数值会怎么样呢？&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\narr.length = 5;\nconsole.log(arr);//[2, 3, 4, 5]\nconsole.log(arr[4]);//undefined\nconsole.log(arr.length);//5\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;可以看到，设置成比较大的数值后，多出来的元素值是undefined&lt;/p&gt;&lt;h4&gt;数组检测&lt;/h4&gt;&lt;p&gt;简单地介绍了Array之后，我们来说说如果检测一个变量是否是一个Array对象。这个也是一个比较常见的话题。&lt;/p&gt;&lt;p&gt;在ES5中，Array新增了一个检测数组对象的方法：Array.isArray。这个方法可以完美地确认一个对象是不是数组，无论这个对象是在哪个全局执行环境中创建的。&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar arr = [2, 3, 4, 5];\nconsole.log(Array.isArray(arr));  //true\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;对于不支持该方法的浏览器中，我们可以采用下面的polyfill：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nif (!Array.isArray) {\n    Array.isArray = function (Obj) {\n        return Object.prototype.toString.apply(Obj) === &quot;[object Array]&quot;;\n    }\n}\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h3&gt;一些常用的数组对象方法&lt;/h3&gt;&lt;p&gt;Array对象中包含着很多有用的方法，尤其是在ES5，ES6中新增了许多方法，下面我们来总结一下。&lt;/p&gt;&lt;h4&gt;静态方法&lt;/h4&gt;&lt;h5&gt;Array.from&lt;/h5&gt;&lt;p&gt;Array.from是ES6种新增的方法，它可以将类数组对象或可迭代对象转换成数组对象。&lt;/p&gt;&lt;p&gt;常见的类数组对象比如有函数的arguments值，或者NodeList，HTMLCollection对象等等。&lt;/p&gt;&lt;p&gt;常见的可迭代对象比如字符串，还有就是ES6新增的Set对象和Map对象。&lt;/p&gt;&lt;p&gt;我们来看看的基本用法，将一个arguments转换成数组对象：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar arr = (function () {\n    return Array.from(arguments);\n})(1, 2, 3);\nconsole.log(arr);//[1,2,3]\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;也可以将一个字符串转换成数组对象：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nconsole.log(Array.from(&quot;abcdefg&quot;)); //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;]\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;Array.from还包含2个可选参数：mapFn，thisArg&lt;/p&gt;&lt;p&gt;mapFn：将from返回的数组再进行处理再返回&lt;/p&gt;&lt;p&gt;thisArg：执行mapFn函数时this指向的值&lt;/p&gt;&lt;p&gt;假设页面上有多个span标签，我们想获取这些span标签里面的文本，这是html代码&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\n\n&amp;lt;span&amp;gt;第一个span&amp;lt;/span&amp;gt;\n&amp;lt;span&amp;gt;第二个span&amp;lt;/span&amp;gt;\n&amp;lt;span&amp;gt;第三个span&amp;lt;/span&amp;gt;\n&amp;lt;span&amp;gt;第四个span&amp;lt;/span&amp;gt;\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;我们要获取span标签里面的文本成组成一个数组，可以这么做：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar spans = document.getElementsByTagName(&quot;span&quot;);\n    var texts = Array.from(spans, function (val, key) {\n        return val.innerText;\n})\nconsole.log(texts);\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;通过from函数将其转换成数组之后，再通过mapFn进行处理，获取每一个元素的innerText。&lt;/p&gt;&lt;p&gt;Array.from是ES6中新增的功能，必然有很多浏览器不支持，可以使用下面的polyfill：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\nvar isArrayLike = function (collection) {\n    var length = collection &amp;amp;&amp;amp; collection.length;\n    return typeof length == &#039;number&#039; &amp;amp;&amp;amp; length &amp;gt;= 0 &amp;amp;&amp;amp; length &amp;lt;= MAX_ARRAY_INDEX;\n};\nvar isFunction = function (fn) {\n    return Object.prototype.toString.call(fn) === &#039;[object Function]&#039;;\n} \n\nif (!Array.from) {\n    Array.from = function (arrayLike, mapFn, thisArg) {\n        if (!isArrayLike(arrayLike)) {\n            throw new TypeError(&quot;被转换的对象不是一个类数组对象或可迭代对象&quot;);\n        }\n        mapFn = isFunction(mapFn) ? mapFn : function (val, key) {\n            return val;\n        }\n    \n        var result = [];\n        for (var i = 0, length = arrayLike.length; i &amp;lt; length; i++) {\n            result.push(mapFn.call(thisArg, arrayLike[i], i));\n        }\n        return result;\n    }\n}\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h5&gt;Array.isArray&lt;/h5&gt;&lt;p&gt;Array.isArray是用来判断一个对象是否是数组，在前面判断数组类型的章节我们已经提到过了，这里就不再赘述啦。&lt;/p&gt;&lt;h5&gt;Array.of&lt;/h5&gt;&lt;p&gt;Array.of方法是ES6中新增的方法，它可以将传入的多个参数作为一个数组返回。看下面例子：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nconsole.log(Array.of(2, 3, 4, 5)); //[2, 3, 4, 5]\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;通过传入4个参数，返回一个包含4个元素的数组。&lt;/p&gt;&lt;p&gt;注意Array.of与采用Array构造函数的区别，看下面代码：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nconsole.log(Array(4));//[]\nconsole.log(Array.of(4));//[4]\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;第一种方式采用Array构造函数的方式，创建了一个4个元素的数组，每个元素的值都是undefined。&lt;/p&gt;&lt;p&gt;第二中方式采用Array.of方法的方式，创建了一个1个元素的数组，元素值是4。&lt;/p&gt;&lt;p&gt;在不支持的浏览器中，可以采用下面的polyfill：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nif (!Array.of) {\n    Array.of = function () {\n        return Array.prototype.slice.call(arguments);\n    };\n}\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h4&gt;继承自Object的方法&lt;/h4&gt;&lt;p&gt;我们知道，所有的引用类型都继承自Object对象，自然而然地包含了Object的一些方法。在Array中，我们主要说说其继承自Object的toString方法和valueOf方法。&lt;/p&gt;&lt;h5&gt;toString方法&lt;/h5&gt;&lt;p&gt;toString方法会返回对象的字符串表示，对于Array来说，这个方法会将每一个元素值用逗号分隔起来，最终形成一个字符串返回：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nconsole.log([1, 2, 3, 4].toString()); //1,2,3,4\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h5&gt;valueOf方法&lt;/h5&gt;&lt;p&gt;valueOf方法用来返回对象的原始值，对于Array来说，它将返回数组本身：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nconsole.log([1, 2, 3, 4].valueOf());//[1,2,3,4]\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h4&gt;元素判断方法&lt;/h4&gt;&lt;p&gt;在ES5中，Array原型中增加了2个判断数组是否满足某一条件的方法，下面分别来说明一下：&lt;/p&gt;&lt;h5&gt;every方法&lt;/h5&gt;&lt;p&gt;every方法用来判断数组中的所有元素是否都满足条件，如果全部满足则返回true，否则false。&lt;/p&gt;&lt;p&gt;every的用法如下：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\narr.every(callback[, thisArg])\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;其中callback是用来判断每个元素是否满足条件的函数，它包含两个参数：元素值，索引，数组本身。&lt;/p&gt;&lt;p&gt;thisArg参数是可选的，它表示callback中this指向的对象。&lt;/p&gt;&lt;p&gt;看看下面的例子：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\n var arr = [1, 2, 3]; \nconsole.log(arr.every(function (val, index) {\n    return val &amp;gt; 0;\n}));//true\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;在不支持的浏览器中，可以采用下面的polyfill：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nif (Array.prototype.every) {\n    Array.prototype.every = function (fn, thisArg) {\n        var arr = this;\n        for (var i = 0, length = arr.length; i &amp;lt; length; i++) {\n            if (!fn.call(thisArg, arr[i], i, arr)) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h5&gt;some方法&lt;/h5&gt;&lt;p&gt;some方法和every方法用法类似，但是它只需要数组中的某一个元素符合条件即返回true。&lt;/p&gt;&lt;p&gt;我们来看下面的例子：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar arr = [1, 2, 3];\nconsole.log(arr.some(function (val, index) {\n    return val &amp;gt; 2;\n}));  //true\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;在数组中，只有一项元素大于2，则返回true。&lt;/p&gt;&lt;p&gt;在不支持的浏览器中，可以采用下面的polyfill：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nif (!Array.prototype.some) {\n    Array.prototype.some = function (fn, thisArg) {\n        var arr = this;\n        for (var i = 0, length = arr.length; i &amp;lt; length; i++) {\n            if (fn.call(thisArg, arr[i], i)) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h4&gt;栈和队列方法&lt;/h4&gt;&lt;p&gt;在js中，数组即可以像栈那个操作，也可以像队列那样操作，它提供了几个关于栈和队列的方法，这些方法相信大家非常熟悉，在这里简单地说明一下：&lt;/p&gt;&lt;h5&gt;pop方法&lt;/h5&gt;&lt;p&gt;pop方法会将数组的最后一个元素删除，然后返回这个被删除的元素&lt;/p&gt;&lt;h5&gt;push方法&lt;/h5&gt;&lt;p&gt;push方法是一个比较常用的方法，和pop方法相反，它用来将一个元素添加到元素的末尾，然后返回数组的长度。&lt;/p&gt;&lt;h5&gt;shift方法&lt;/h5&gt;&lt;p&gt;shift方法将第一个元素删除，然后返回这个元素&lt;/p&gt;&lt;h5&gt;unshift方法&lt;/h5&gt;&lt;p&gt;unshift在数组开头添加一个或多个元素，然后返回这个元素的长度：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar arr = [1, 2, 3];\nconsole.log(arr.unshift(3, 2, 1));//6\nconsole.log(arr);  // [3,2,1,1,2,3]\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h4&gt;元素索引方法&lt;/h4&gt;&lt;h5&gt;indexOf方法&lt;/h5&gt;&lt;p&gt;indexOf方法用来返回元素在数组中的位置，不存在则返回-1：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar arr = [1, 2, 3];\nconsole.log(arr.indexOf(2));  //1\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;indexOf方法有第二个可选参数，这个参数表示从哪个索引开始查找：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nconsole.log(arr.indexOf(2, 1)); //1\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;如果这个参数大于数组长度，则直接返回-1，如果是负数，则将末尾进行抵消，然后开始查找，比如-1就从倒数第一开始查找，-2从倒数第二开始查找。&lt;/p&gt;&lt;p&gt;indexOf方法是ES5中提供的方法，对于不支持的浏览器，可以采用下面的polyfill：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nif (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function (element, fromIndex) {\n        if (this.length === 0 || this.length &amp;lt; fromIndex) {\n            return -1;\n        }\n        var index = fromIndex || 0;\n        var length = this.length;\n        if (fromIndex &amp;lt; 0) {\n            index = length + fromIndex;\n        }\n            \n        for (; index &amp;lt; length; index++) {\n            if (this[index] === element) {\n                return index;\n            }\n        }\n        return -1;\n    }\n}\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h5&gt;lastIndexOf方法&lt;/h5&gt;&lt;p&gt;lastIndexOf方法和indexOf方法类似，它用于查找元素在数组最后一项的索引，如果不存在则返回-1：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar arr = [1, 5, 3, 4, 5, 6, 7];\nconsole.log(arr.indexOf(5));//1\nconsole.log(arr.lastIndexOf(5));  //4\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;如上面例子所示，数组中存在着两个数字5，使用indexOf方法将返回1，使用lastIndexOf将返回5。&lt;/p&gt;&lt;p&gt;lastIndexOf方法同样拥有第二个可选参数fromIndex，表示从该位置开始逆向查找。&lt;/p&gt;&lt;p&gt;如果fromIndex值大于或等于数组长度，则整个数组都会被查找。&lt;/p&gt;&lt;p&gt;如果fromIndex值为负值，并且其绝对值小于数组长度时，将从数组末尾向前查找。&lt;/p&gt;&lt;p&gt;如果fromIndex只为负数，但是其绝对值大于数组长度时，则直接返回-1。&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar arr = [1, 5, 3, 4, 5, 6, 7];\nconsole.log(arr.lastIndexOf(5, 10)); //4 \nconsole.log(arr.lastIndexOf(5, -4));  //1\nconsole.log(arr.lastIndexOf(5, -10));  //-1\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;对于不支持的浏览器，可以使用下面的polyfill：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nif (!Array.prototype.lastIndexOf) {\n    Array.prototype.lastIndexOf = function (element, fromIndex) {\n        if (this.length === 0 || (fromIndex &amp;lt; 0 &amp;amp;&amp;amp; this.length &amp;lt; Math.abs(fromIndex))) {\n            return -1;\n        }\n            \n        var length = this.length;\n        var index = fromIndex || length - 1;\n        if (fromIndex &amp;lt; 0) {\n            index = length + fromIndex;\n        }\n        \n        for (; index &amp;gt; -1; index--) {\n            if (this[index] === element) {\n                return index;\n            }\n        }\n        return -1;\n    }\n}\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h4&gt;元素查找方法&lt;/h4&gt;&lt;h5&gt;findIndex方法&lt;/h5&gt;&lt;p&gt;findIndex方法用来查找数组中符合条件的元素的索引，如果没有则返回-1。它包含两个参数：&lt;/p&gt;&lt;p&gt;callback：用来判断元素是否符合条件的回调函数，包含三个参数，分别是：当前元素，当前元素索引，数组&lt;/p&gt;&lt;p&gt;thisArg：可选参数，表示callback中this对象。&lt;/p&gt;&lt;p&gt;来看看下面的例子：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar arr = [1, 2, 3, 4, 5, 6];\n    console.log(arr.findIndex(function (val, idx) {\n        return val &amp;gt; 3;\n})) //3\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;查找第一个大于3的元素的索引，结果为3。&lt;/p&gt;&lt;p&gt;如果是一个比较复杂元素的数组，我们可以来查找其中符合某个条件的元素的索引：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\n var arr = [{ a: 1 }, { a: 2 }];\nconsole.log(arr.indexOf({ a: 2 }));//-1\nconsole.log(arr.findIndex(function (val, idx) {\n    return val.a == 2;//1\n}));\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;如果是要查找一个复杂对象，使用indexOf可能查找不到其索引，但是我们可以通过findIndex来找到其索引。这个对于查找复杂元素非常有用。&lt;/p&gt;&lt;p&gt;对于不支持的浏览器，可以使用下面的polyfill：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nif (!Array.prototype.findIndex) {\n    Array.prototype.findIndex = function (fn, thisArg) {\n        if (!isFunction(fn)) {\n            throw new TypeError(&quot;fn不是一个有效的函数&quot;);\n        }\n        \n        var arr = this;\n        for (var i = 0, length = arr.length; i &amp;lt; length; i++) {\n            if (fn.call(thisArg, arr[i], i, arr)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h5&gt;find方法&lt;/h5&gt;&lt;p&gt;find方法用户查找满足条件的第一个元素，如果没有满足条件的元素，则返回undefined。&lt;/p&gt;&lt;p&gt;find方法的用法和findIndex类似，它包含两个参数：&lt;/p&gt;&lt;p&gt;callback：用来判断元素是否符合条件的回调函数，包含三个参数，分别是：当前元素，当前元素索引，数组&lt;/p&gt;&lt;p&gt;thisArg：可选参数，表示callback中this对象。&lt;/p&gt;&lt;p&gt;来看看下面的例子：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar arr = [{ v: 1 }, { v: 3 }, { v: 4 }, { v: 5 }, { v: 6 }];\n    console.log(arr.find(function (val, idx) {\n        return val.v &amp;gt; 3;\n}))//Object {v: 4}\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;通过find方法，查找到第一个其属性v大于3的元素并返回。&lt;/p&gt;&lt;p&gt;大家在日常的开发中一定会遇到这种查找符合条件的元素的需求，find方法是一个非常有用的方法。&lt;/p&gt;&lt;p&gt;对于不支持的浏览器，可以采用下面的polyfill：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nif (!Array.prototype.find) {\n    Array.prototype.find = function (fn, thisArg) {\n        if (!isFunction(fn)) {\n            throw new TypeError(&quot;fn不是一个有效的函数&quot;);\n        }\n        var arr = this;\n        for (var i = 0, length = arr.length; i &amp;lt; length; i++) {\n            if (fn.call(thisArg, arr[i], i, arr)) {\n                return arr[i];\n            }\n        }\n    }\n}\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h4&gt;元素排序方法&lt;/h4&gt;&lt;p&gt;在Array对象中，它还包含了一些排序的方法，主要有sort和reverse两个方法，下面来说明一下这两个方法。&lt;/p&gt;&lt;h5&gt;sort方法&lt;/h5&gt;&lt;p&gt;sort方法用来对数组进行排序，并返回排序后的数组。它包含一个参数，这个参数是一个函数，用它来比较每个参数之前的前后关系。如果不传，则默认按照字符串的Unicode码位点进行排序。&lt;/p&gt;&lt;p&gt;看看下面的例子：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nvar arr = [2, 4, 6, 2, 4, 8, 11, 34];\nconsole.log(arr.sort().toString());  //11,2,2,34,4,4,6,8\nconsole.log(arr.sort(\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&quot;fuwenben963', 1566743152246, 'liuwk', '详解Javascript中的Array对象', '3', 15);
INSERT INTO `blogs` VALUES (102, 'Javascript中apply、call、bind', 'fuwenben963&quot;&lt;p&gt;在 javascript 中，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。&lt;/p&gt;&lt;h2&gt;apply、call&lt;/h2&gt;&lt;p&gt;JavaScript 的一大特点是，函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。&lt;/p&gt;&lt;p&gt;先来一个栗子：&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;function fruits() {}\n\nfruits.prototype = {\n    color: &quot;red&quot;,\n    say: function() {\n        console.log(&quot;My color is &quot; + this.color);\n    }\n}\n\nvar apple = new fruits;\napple.say();    //My color is red\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;但是如果我们有一个对象banana= {color : &quot;yellow&quot;} ,我们不想对它重新定义 say 方法，那么我们可以通过 call 或 apply 用 apple 的 say 方法：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;banana = {\n    color: &quot;yellow&quot;\n}\napple.say.call(banana);     //My color is yellow\napple.say.apply(banana);    //My color is yellow\n&lt;/pre&gt;&lt;p&gt;所以，可以看出 call 和 apply 是为了动态改变 this 而出现的，当一个 object 没有某个方法（本栗子中banana没有say方法），但是其他的有（本栗子中apple有say方法），我们可以借助call或apply用其它对象的方法来操作。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h3&gt;apply、call 的区别&lt;/h3&gt;&lt;p&gt;对于 apply、call 二者而言，作用完全一样，只是接受参数的方式不太一样。例如，有一个函数定义如下：&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt; var func = function(arg1, arg2) {\n};\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;就可以通过如下方式来调用：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;func.call(this, arg1, arg2);\nfunc.apply(this, [arg1, arg2])\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;其中 this 是你想指定的上下文，他可以是任何一个 JavaScript 对象(JavaScript 中一切皆对象)，call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。&lt;/p&gt;&lt;p&gt;JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时用 call 。&lt;/p&gt;&lt;p&gt;而不确定的时候用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个伪数组来遍历所有的参数。&lt;/p&gt;&lt;p&gt;为了巩固加深记忆，下面列举一些常用用法：&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h4&gt;1、数组之间追加&lt;/h4&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;var array1 = [12 , &quot;foo&quot; , {name &quot;Joe&quot;} , -2458]; \nvar array2 = [&quot;Doe&quot; , 555 , 100]; \nArray.prototype.push.apply(array1, array2); \n/* array1 值为  [12 , &quot;foo&quot; , {name &quot;Joe&quot;} , -2458 , &quot;Doe&quot; , 555 , 100] */\n&lt;/pre&gt;&lt;h4&gt;2、获取数组中的最大值和最小值&lt;/h4&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;var  numbers = [5, 458 , 120 , -215 ]; \nvar maxInNumbers = Math.max.apply(Math, numbers),   //458\n    maxInNumbers = Math.max.call(Math,5, 458 , 120 , -215); //458\n&lt;/pre&gt;&lt;h4&gt;3、验证是否是数组（前提是toString()方法没有被重写过）&lt;/h4&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;functionisArray(obj){ \n    return Object.prototype.toString.call(obj) === &#039;[object Array]&#039; ;\n}\n&lt;/pre&gt;&lt;h4&gt;4、类（伪）数组使用数组方法&lt;/h4&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;    var domNodes = Array.prototype.slice.call(document.getElementsByTagName(&quot;*&quot;));\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Javascript中存在一种名为伪数组的对象结构。比较特别的是 arguments 对象，还有像调用 getElementsByTagName , document.childNodes 之类的，它们返回NodeList对象都属于伪数组。不能应用 Array下的 push , pop 等方法。&lt;/p&gt;&lt;p&gt;但是我们能通过 Array.prototype.slice.call 转换为真正的数组的带有 length 属性的对象，这样 domNodes 就可以应用 Array 下的所有方法了。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h2&gt;bind&lt;/h2&gt;&lt;p&gt;说完了 apply 和 call ，再来说说bind。bind() 方法与 apply 和 call 很相似，也是可以改变函数体内 this 的指向。&lt;/p&gt;&lt;p&gt;MDN的解释是：bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入&amp;nbsp;bind()方法的第一个参数作为&amp;nbsp;this，传入&amp;nbsp;bind()&amp;nbsp;方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。&lt;/p&gt;&lt;p&gt;直接来看看具体如何使用，在常见的单体模式中，通常我们会使用 _this , that , self 等保存 this ，这样我们可以在改变了上下文之后继续引用到它。&amp;nbsp;像这样：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;var foo = {\n    bar : 1,\n    eventBind: function(){\n        var _this = this;\n        $(&#039;.someClass&#039;).on(&#039;click&#039;,function(event) {\n            /* Act on the event */\n            console.log(_this.bar);     //1\n        });\n    }\n}\n&lt;/pre&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(0, 108, 255);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;由于 Javascript 特有的机制，上下文环境在 eventBind:function(){ } 过渡到&amp;nbsp;$(&#039;.someClass&#039;).on(&#039;click&#039;,function(event) {&amp;nbsp;})&amp;nbsp;发生了改变，上述使用变量保存&amp;nbsp;this&amp;nbsp;这些方式都是有用的，也没有什么问题。&lt;/p&gt;&lt;p&gt;当然使用 bind() 可以更加优雅的解决这个问题：&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;var foo = {\n    bar : 1,\n    eventBind: function(){\n        $(&#039;.someClass&#039;).on(&#039;click&#039;,function(event) {\n            /* Act on the event */\n            console.log(this.bar);      //1\n        }.bind(this));\n    }\n}\n&lt;/pre&gt;&lt;p&gt;在上述代码里，bind() 创建了一个函数，当这个click事件绑定在被调用的时候，它的 this 关键词会被设置成被传入的值（这里指调用bind()时传入的参数）。&lt;/p&gt;&lt;p&gt;因此，这里我们传入想要的上下文 this(其实就是 foo )，到 bind() 函数中。然后，当回调函数被执行的时候， this 便指向&amp;nbsp;foo&amp;nbsp;对象。再来一个简单的栗子：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;var bar = function(){\nconsole.log(this.x);\n}\nvar foo = {\nx:3\n}\nbar(); // undefined\nvar func = bar.bind(foo);\nfunc(); // 3\n&lt;/pre&gt;&lt;p&gt;这里我们创建了一个新的函数 func，当使用 bind() 创建一个绑定函数之后，它被执行的时候，它的 this 会被设置成 foo ， 而不是像我们调用 bar() 时的全局作用域。&lt;/p&gt;&lt;p&gt;有个有趣的问题，如果连续 bind() 两次，亦或者是连续 bind() 三次那么输出的值是什么呢？像这样：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;var bar = function(){\n    console.log(this.x);\n}\nvar foo = {\n    x:3\n}\nvar sed = {\n    x:4\n}\nvar func = bar.bind(foo).bind(sed);\nfunc(); //? \n\nvar fiv = {\n    x:5\n}\nvar func = bar.bind(foo).bind(sed).bind(fiv);\nfunc(); //? \n&lt;/pre&gt;&lt;p&gt;答案是，两次都仍将输出 3 ，而非期待中的 4 和 5 。&lt;/p&gt;&lt;p&gt;原因是，在Javascript中，多次 bind() 是无效的。更深层次的原因， bind() 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 bind() 相当于再包住第一次 bind() ,故第二次以后的 bind 是无法生效的。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h2&gt;apply、call、bind比较&lt;/h2&gt;&lt;p&gt;那么 apply、call、bind 三者相比较，之间又有什么异同呢？何时使用 apply、call，何时使用 bind 呢。简单的一个栗子：&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;var obj = {\n    x: 81,\n};\n\nvar foo = {\n    getX: function() {\n        return this.x;\n    }\n}\n\nconsole.log(foo.getX.bind(obj)());  //81\nconsole.log(foo.getX.call(obj));    //81\nconsole.log(foo.getX.apply(obj));   //81\n&lt;/pre&gt;&lt;p&gt;三个输出的都是81，但是注意看使用 bind() 方法的，他后面多了对括号。&lt;/p&gt;&lt;p&gt;也就是说，区别是，当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数。&lt;/p&gt;&lt;p&gt;再总结一下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；&lt;/li&gt;&lt;li&gt;apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；&lt;/li&gt;&lt;li&gt;apply 、 call 、bind 三者都可以利用后续参数传参；&lt;/li&gt;&lt;li&gt;bind&amp;nbsp;是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&quot;fuwenben963', 1566743279604, 'liuwk', 'Javascript中apply、call、bind', '2', 45);
INSERT INTO `blogs` VALUES (103, '连接 mysql 出现Client does not support authentication ', 'fuwenben963&quot;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;USE mysql;\nALTER USER &#039;root&#039;@&#039;localhost&#039; IDENTIFIED WITH mysql_native_password BY &#039;831015&#039;;\nFLUSH PRIVILEGES;\n\n&lt;/pre&gt;&lt;p&gt;root是用户名，localhost是ip地址127.0.0.1都是特指本机，mysql_native_password是旧的密码验证机制，831015是密码，最后别忘了分号；&lt;/p&gt;&lt;p&gt;最后问题解决：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/2018051410382813?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM3MDAzNTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&quot;fuwenben963', 1566743312230, 'liuwk', '连接 mysql 出现Client does not support authentication ', '3', 16);
INSERT INTO `blogs` VALUES (104, 'vue项目中路由切换使用 animate.css 动画库', 'fuwenben963&quot;&lt;p&gt;vue-cli初始项目，这个不用再详说了吧&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190808092500354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMTYwOTM=,size_16,color_FFFFFF,t_70&quot; alt=&quot;å¨è¿éæå¥å¾çæè¿°&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;lt;link href=&quot;https://cdn.bootcss.com/animate.css/3.5.2/animate.min.css&quot; rel=&quot;stylesheet&quot;&amp;gt;\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我直接在 index.html 中引入 animate.css 库&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在 App.vue 中 transition 标签定义好进入、离开的变量 class ， 在 router-view 定义好 class animated ， animate.css的用法必须定义calss：animated&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;&amp;lt;template&amp;gt;\n&amp;nbsp;&amp;lt;div id=&quot;app&quot;&amp;gt;\n&amp;nbsp;&amp;nbsp;&amp;lt;home :isTop=&quot;isTop&quot;&amp;gt;&amp;lt;/home&amp;gt;\n\n&amp;nbsp;&amp;nbsp;&amp;lt;div class=&quot;routerView&quot;&amp;gt;\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;transition :enter-active-class=&quot;enterClass&quot; :leave-active-class=&quot;leaveClass&quot;&amp;gt;\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;router-view class=&quot;animated&quot;&amp;gt;&amp;lt;/router-view&amp;gt;\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;/transition&amp;gt;\n&amp;nbsp;&amp;nbsp;&amp;lt;/div&amp;gt;\n\n&amp;nbsp;&amp;lt;/div&amp;gt;\n&amp;lt;/template&amp;gt;\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;ClassArr 就是保存的 animate.css 的 css动画样式，我这随机选的十几个css样式名&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\n&amp;nbsp;&amp;nbsp;data() {\n&amp;nbsp;&amp;nbsp;&amp;nbsp;return {\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;isTop: false,\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;transitionName: &#039;slide-right&#039;,\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;enterClass: &#039;&#039;,\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;leaveClass: &#039;&#039;,\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ClassArr: [&#039;rubberBand&#039;,&#039;pulse&#039;,&#039;swing&#039;,&#039;tada&#039;,&#039;wobble&#039;,&#039;heartBeat&#039;,&#039;fadeOut&#039;,&#039;flipInX&#039;,&#039;flipInY&#039;,&#039;flipOutX&#039;,&#039;flipOutY&#039;,&#039;rotateIn&#039;,&#039;rotateOut&#039;,&#039;rotateOutDownLeft&#039;,&#039;rotateOutDownRight&#039;,&#039;rotateOutUpLeft&#039;,&#039;rotateOutUpRight&#039;,&#039;hinge&#039;,&#039;jackInTheBox&#039;,&#039;rollIn&#039;,&#039;rollOut&#039;]\n&amp;nbsp;&amp;nbsp;&amp;nbsp;}\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;监听路由变化&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;watch: {\n&amp;nbsp;$route(to, from) {\n&amp;nbsp;&amp;nbsp;this.leaveClass = this.ClassArr[this.random()];\n&amp;nbsp;&amp;nbsp;setTimeout(()=&amp;gt;{\n&amp;nbsp;&amp;nbsp;&amp;nbsp;this.enterClass = this.ClassArr[this.random()];\n&amp;nbsp;&amp;nbsp;},500)\n&amp;nbsp;}\n},\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;methods方法中定义随机数&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;random() {\n&amp;nbsp;&amp;nbsp;//定义随机数，对应好 this.ClassArr.length 的长度，我这里 length 是 21\n&amp;nbsp;&amp;nbsp;return Math.floor(Math.random() * (1 - 21) + 21)\n&amp;nbsp;}\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&quot;fuwenben963', 1566743510310, 'liuwk', 'vue项目中路由切换使用 animate.css 动画库', '3', 17);
INSERT INTO `blogs` VALUES (105, '前端 nginx 跨域访问配置', 'fuwenben963&quot;&lt;p&gt;1、首先下载nginx ： http://nginx.org/en/download.html&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;2、&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;一般选择 Stable version 稳定版&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;3、 下载后 解压 随意放在那个盘 我以前下载的 nginx-1.12.0 版本&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;4、 E:\nginx-1.12.0conf\nginx.conf 我这放在E盘 打开 nginx.conf&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;#user&amp;nbsp;nobody;\nworker_processes&amp;nbsp;1;\n\n#error_log&amp;nbsp;logs/error.log;\n#error_log&amp;nbsp;logs/error.log&amp;nbsp;notice;\n#error_log&amp;nbsp;logs/error.log&amp;nbsp;info;\n\n#pid&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;logs/nginx.pid;\n\n\nevents {\n&amp;nbsp;&amp;nbsp;worker_connections&amp;nbsp;1024;\n}\n\n\nhttp {\n&amp;nbsp;&amp;nbsp;include&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;mime.types;\n&amp;nbsp;&amp;nbsp;default_type&amp;nbsp;application/octet-stream;\n\n#log_format&amp;nbsp;main&amp;nbsp;&#039;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#039;\n#&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#039;$status $body_bytes_sent &quot;$http_referer&quot; &#039;\n#&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#039;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#039;;\n\n#access_log&amp;nbsp;logs/access.log&amp;nbsp;main;\n\nsendfile&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;on;\n#tcp_nopush&amp;nbsp;&amp;nbsp;&amp;nbsp;on;\n\n#keepalive_timeout&amp;nbsp;0;\nkeepalive_timeout&amp;nbsp;65;\n\n#gzip&amp;nbsp;on;\n\nserver {\n&amp;nbsp;&amp;nbsp;listen&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;80;&amp;nbsp;&amp;nbsp;##&amp;nbsp;随意改动&amp;nbsp;我这里不改\n&amp;nbsp;&amp;nbsp;server_name&amp;nbsp;localhost;&amp;nbsp;&amp;nbsp;##\n\n&amp;nbsp;&amp;nbsp;#charset utf-8;&amp;nbsp;//&amp;nbsp;&amp;nbsp;##改为 utf-8;&amp;nbsp;\n\n&amp;nbsp;&amp;nbsp;#access_log&amp;nbsp;logs/host.access.log&amp;nbsp;main;\n\n&amp;nbsp;&amp;nbsp;location / {\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;root&amp;nbsp;&amp;nbsp;html;&amp;nbsp;&amp;nbsp;##主页&amp;nbsp;&amp;nbsp;可改为其他目录\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;index&amp;nbsp;index.html index.htm;&amp;nbsp;&amp;nbsp;## 主页目录入口\n&amp;nbsp;&amp;nbsp;}\n\n\n&amp;nbsp;&amp;nbsp;location /apis/{&amp;nbsp;## 这个名称在后面请求的时候用到\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;proxy_pass&amp;nbsp;http://192.168.0.104/;&amp;nbsp;##&amp;nbsp;我这是后台的接口地址\n&amp;nbsp;&amp;nbsp;}\n\n&amp;nbsp;&amp;nbsp;#error_page&amp;nbsp;404&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/404.html;\n\n&amp;nbsp;&amp;nbsp;# redirect server error pages to the static page /50x.html\n&amp;nbsp;&amp;nbsp;#\n&amp;nbsp;&amp;nbsp;error_page&amp;nbsp;&amp;nbsp;500 502 503 504&amp;nbsp;/50x.html;\n&amp;nbsp;&amp;nbsp;location = /50x.html {\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;root&amp;nbsp;&amp;nbsp;html;\n&amp;nbsp;&amp;nbsp;}\n\n&amp;nbsp;&amp;nbsp;# proxy the PHP scripts to Apache listening on 127.0.0.1:80\n&amp;nbsp;&amp;nbsp;#\n&amp;nbsp;&amp;nbsp;#location ~ .php$ {\n&amp;nbsp;&amp;nbsp;#&amp;nbsp;&amp;nbsp;proxy_pass&amp;nbsp;&amp;nbsp;http://127.0.0.1;\n&amp;nbsp;&amp;nbsp;#}\n\n&amp;nbsp;&amp;nbsp;# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n&amp;nbsp;&amp;nbsp;#\n&amp;nbsp;&amp;nbsp;#location ~ .php$ {\n&amp;nbsp;&amp;nbsp;#&amp;nbsp;&amp;nbsp;root&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;html;\n&amp;nbsp;&amp;nbsp;#&amp;nbsp;&amp;nbsp;fastcgi_pass&amp;nbsp;&amp;nbsp;127.0.0.1:9000;\n&amp;nbsp;&amp;nbsp;#&amp;nbsp;&amp;nbsp;fastcgi_index&amp;nbsp;index.php;\n&amp;nbsp;&amp;nbsp;#&amp;nbsp;&amp;nbsp;fastcgi_param&amp;nbsp;SCRIPT_FILENAME&amp;nbsp;/scripts$fastcgi_script_name;\n&amp;nbsp;&amp;nbsp;#&amp;nbsp;&amp;nbsp;include&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;fastcgi_params;\n&amp;nbsp;&amp;nbsp;#}\n\n&amp;nbsp;&amp;nbsp;# deny access to .htaccess files, if Apache&#039;s document root\n&amp;nbsp;&amp;nbsp;# concurs with nginx&#039;s one\n&amp;nbsp;&amp;nbsp;#\n&amp;nbsp;&amp;nbsp;#location ~ /.ht {\n&amp;nbsp;&amp;nbsp;#&amp;nbsp;&amp;nbsp;deny&amp;nbsp;all;\n&amp;nbsp;&amp;nbsp;#}\n}\n\n\n# another virtual host using mix of IP-, name-, and port-based configuration\n#\n#server {\n#&amp;nbsp;&amp;nbsp;listen&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;8000;\n#&amp;nbsp;&amp;nbsp;listen&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;somename:8080;\n#&amp;nbsp;&amp;nbsp;server_name&amp;nbsp;somename&amp;nbsp;alias&amp;nbsp;another.alias;\n\n#&amp;nbsp;&amp;nbsp;location / {\n#&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;root&amp;nbsp;&amp;nbsp;html;\n#&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;index&amp;nbsp;index.html index.htm;\n#&amp;nbsp;&amp;nbsp;}\n#}\n\n\n# HTTPS server\n#\n#server {\n#&amp;nbsp;&amp;nbsp;listen&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;443 ssl;\n#&amp;nbsp;&amp;nbsp;server_name&amp;nbsp;localhost;\n\n#&amp;nbsp;&amp;nbsp;ssl_certificate&amp;nbsp;&amp;nbsp;&amp;nbsp;cert.pem;\n#&amp;nbsp;&amp;nbsp;ssl_certificate_key&amp;nbsp;cert.key;\n\n#&amp;nbsp;&amp;nbsp;ssl_session_cache&amp;nbsp;&amp;nbsp;shared:SSL:1m;\n#&amp;nbsp;&amp;nbsp;ssl_session_timeout&amp;nbsp;5m;\n\n#&amp;nbsp;&amp;nbsp;ssl_ciphers&amp;nbsp;HIGH:!aNULL:!MD5;\n#&amp;nbsp;&amp;nbsp;ssl_prefer_server_ciphers&amp;nbsp;on;\n\n#&amp;nbsp;&amp;nbsp;location / {\n#&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;root&amp;nbsp;&amp;nbsp;html;\n#&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;index&amp;nbsp;index.html index.htm;\n#&amp;nbsp;&amp;nbsp;}\n#}&amp;nbsp;\n#&amp;nbsp;&amp;nbsp;}\n\n120\n&lt;/pre&gt;&lt;p&gt;保存&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;启动 E:\nginx-1.12.0 下的 nginx.exe 然后浏览器打开 localhost&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这是前端的页面代码&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;\n&amp;lt;html&amp;gt;\n\n&amp;lt;head&amp;gt;\n&amp;nbsp;&amp;nbsp;&amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;\n&amp;nbsp;&amp;nbsp;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;\n&amp;lt;/head&amp;gt;\n&amp;lt;script type=&quot;text/javascript&quot; src=&quot;https://code.jquery.com/jquery-3.1.0.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;\n&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;\n&amp;nbsp;&amp;nbsp;$(function() {\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$.ajax({\n&amp;nbsp;&amp;nbsp;&amp;nbsp;		&amp;nbsp;&amp;nbsp;//http://192.168.0.104/admin/employee/getTree&amp;nbsp;原来后台的接口\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;url: &quot;http://localhost/apis/admin/employee/getTree&quot;, //&amp;nbsp;这里直接改成&amp;nbsp;&amp;nbsp;apis&amp;nbsp;会通过ngiux转为我们设置的接口\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//url: &quot;apis/movie/in_theaters&quot;, //&amp;nbsp;或者改成这样\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;type: &quot;GET&quot;,\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;success: function (data) {\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$(&quot;.text&quot;).html(JSON.stringify(data));\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;},\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;error: function (text) {\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$(&quot;text&quot;).html(JSON.stringify(text))\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});\n&amp;nbsp;&amp;nbsp;});\n&amp;lt;/script&amp;gt;\n\n&amp;lt;body&amp;gt;\n&amp;lt;span class=&quot;text&quot;&amp;gt;&amp;lt;/span&amp;gt;\n&amp;lt;/body&amp;gt;\n\n&amp;lt;/html&amp;gt;\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;成功&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/201812141750551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMTYwOTM=,size_16,color_FFFFFF,t_70&quot; alt=&quot;å¨è¿éæå¥å¾çæè¿°&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&quot;fuwenben963', 1566743592391, 'liuwk', '前端 nginx 跨域访问配置', '3', 16);
INSERT INTO `blogs` VALUES (106, '记一次微信小程序登陆', 'fuwenben963&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;大家都熟悉的btn 按钮授权，&lt;strong&gt;getUserInfo &lt;/strong&gt; 接口没法弹窗，大家都应该知道&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;&quot;&gt;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;   &amp;lt;button bindgetuserinfo=&quot;empower&quot; wx:if=&quot;{{!isEmpower}}&quot; open-type=&quot;getUserInfo&quot;&amp;gt;授权小程序&amp;lt;/button&amp;gt;\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;绑定了 bindgetuserinfo 事件 用来触发 确定的回调&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;  /**\n   * 授权\n   */\n  empower(res) {\n\n\n    let that = this;\n\n    if (res.detail.errMsg == &#039;getUserInfo:ok&#039;) {\n\n      wx.showLoading({\n        title: &#039;加载中&#039;,\n      })\n\n\n\n      let that = this\n      wx.login({\n        success: e =&amp;gt; {\n          let code = e.code\n\n          // 登录注册接口\n          if (code) {\n            // 调用服务端登录接口，发送 res.code 到服务器端换取 openId, sessionKey, unionId并存入数据库中\n            wx.getUserInfo({\n              success: function(result) {\n\n                wx.request({\n                  url: BASE_URL + &#039;/wxa/login?code=&#039; + code,\n                  method: &#039;post&#039;,\n                  data: {\n                    code\n                  },\n                  success: (res) =&amp;gt; {\n                    wx.setStorageSync(&#039;codeInfo&#039;, result);\n                    let encryptedData = result.encryptedData;\n                    that.fetchWxlogin(res, encryptedData, result.iv); //调用服务器api\n\n                  }\n                })\n\n              }\n            })\n          }\n        }\n      });\n    }\n  },\n\n\n\n  fetchWxlogin(res, encryptedData, iv) {\n    let that = this\n    let Authorization = CusBase64.CusBASE64.encoder(`${config.client_id}:${config.client_secret}`); // 这个是我和后台的约定\n    wx.request({\n      url: BASE_URL + &#039;&#039;/oauth/token&#039;&#039;,\n      method: &#039;&#039;post&#039;&#039;,\n      data: {\n        sessionKey: res.data.sessionKey,\n        grant_type: &#039;wxa&#039;,\n        encryptedData,\n        iv\n      },\n      header: {\n        &#039;Content-Type&#039;: &#039;application/x-www-form-urlencoded&#039;,\n        &#039;Authorization&#039;: `Basic ${Authorization}`\n      },\n      success: result =&amp;gt; {\n        if (result.data.access_token) {\n          let expireTime = new Date().valueOf() + result.data.expires_in * 1000;\n          result.data.expireTime = expireTime;\n          try {\n            app.globalData.token = result.data;\n            wx.setStorageSync(&#039;tokenInfo&#039;, result.data);\n\n\n            that.setData({\n              isEmpower: true\n            }, () =&amp;gt; {\n              wx.hideLoading();\n              that.fetchProfile() //  这是我调个人信息的接口  全部授权后就可以查看个人信息了\n\n            })\n\n          } catch (err) {\n            console.error(err);\n          }\n\n        }\n\n      }\n    })\n  },\n\n\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;fuwenben963', 1566784147167, 'liuwk', '使用用户授权的信息登陆小程序', '3', 50);
INSERT INTO `blogs` VALUES (109, '空战飞行员无限金钱破解版', 'fuwenben963&lt;p&gt;&lt;img src=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;	这是一款刺激有趣的动作冒险射击手机游戏！在游戏中玩家将置身与这个充满战争的世界；&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;	用你娴熟的操作以及飞行的技巧，来帮助军队赢得最终的胜利。(已修改无限金钱)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;蓝凑云： &lt;a href=&quot;https://www.lanzous.com/i649b8d&quot; target=&quot;_blank&quot;&gt;https://www.lanzous.com/i649b8d&lt;/a&gt;&lt;/p&gt;fuwenben963', 1568257991875, 'lisi', '这是一款刺激有趣的动作冒险射击手机游戏！在游戏中玩家将置身与这个充满战争的世界；', '4', 13);
INSERT INTO `blogs` VALUES (110, 'VUE history  模式Nginx配置', 'fuwenben963&lt;p&gt;&lt;strong&gt;nginx&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;server\n{\n&amp;nbsp; &amp;nbsp; listen 80;\n&amp;nbsp; &amp;nbsp; server_name emlog.sxitw.cn www.sxitw.cn sxitw.cn;  //配置域名\n&amp;nbsp; &amp;nbsp; index index.php index.html index.htm default.php default.htm default.html;  // 配置首页\n&amp;nbsp; &amp;nbsp; root /www/wwwroot/sxitw.cn;  //  文件所在目录\n&amp;nbsp; &amp;nbsp;&amp;nbsp;\n&amp;nbsp; &amp;nbsp; #SSL-START SSL相关配置，请勿删除或修改下一行带注释的404规则\n&amp;nbsp; &amp;nbsp; #error_page 404/404.html;\n&amp;nbsp; &amp;nbsp; #SSL-END\n&amp;nbsp; &amp;nbsp;&amp;nbsp;\n&amp;nbsp; &amp;nbsp; #ERROR-PAGE-START&amp;nbsp; 错误页配置，可以注释、删除或修改\n&amp;nbsp; &amp;nbsp; #error_page 404 /404.html;\n&amp;nbsp; &amp;nbsp; #error_page 502 /502.html;\n&amp;nbsp; &amp;nbsp; #ERROR-PAGE-END\n&amp;nbsp; &amp;nbsp;&amp;nbsp;\n&amp;nbsp; &amp;nbsp; #PHP-INFO-START&amp;nbsp; PHP引用配置，可以注释或修改\n&amp;nbsp; &amp;nbsp; include enable-php-54.conf;\n&amp;nbsp; &amp;nbsp; #PHP-INFO-END\n&amp;nbsp; &amp;nbsp;&amp;nbsp;\n&amp;nbsp; &amp;nbsp; #REWRITE-START URL重写规则引用,修改后将导致面板设置的伪静态规则失效\n&amp;nbsp; &amp;nbsp; include /www/server/panel/vhost/rewrite/sxitw.cn.conf;\n&amp;nbsp; &amp;nbsp; #REWRITE-END\n&amp;nbsp; &amp;nbsp;&amp;nbsp;\n&amp;nbsp; &amp;nbsp; #禁止访问的文件或目录\n&amp;nbsp; &amp;nbsp; location ~ ^/(.user.ini|.htaccess|.git|.svn|.project|LICENSE|README.md)\n&amp;nbsp; &amp;nbsp; {\n&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return 404;\n&amp;nbsp; &amp;nbsp; }\n&amp;nbsp; &amp;nbsp;&amp;nbsp;\n&amp;nbsp; &amp;nbsp; location / {\n      &amp;nbsp; try_files $uri $uri/ /index.html;  //  按照 vue history 的配置\n        }\n        &amp;nbsp; &amp;nbsp;&amp;nbsp;\n    #一键申请SSL证书验证目录相关设置\n&amp;nbsp; &amp;nbsp; location ~ .well-known{\n&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; allow all;\n&amp;nbsp; &amp;nbsp; }\n&amp;nbsp; &amp;nbsp;&amp;nbsp;\n&amp;nbsp; &amp;nbsp; location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$\n&amp;nbsp; &amp;nbsp; {\n&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; expires&amp;nbsp; &amp;nbsp; &amp;nbsp; 30d;\n&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; error_log off;\n&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; access_log /dev/null;\n&amp;nbsp; &amp;nbsp; }\n&amp;nbsp; &amp;nbsp;&amp;nbsp;\n&amp;nbsp; &amp;nbsp; location ~ .*.(js|css)?$\n&amp;nbsp; &amp;nbsp; {\n&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; expires&amp;nbsp; &amp;nbsp; &amp;nbsp; 12h;\n&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; error_log off;\n&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; access_log /dev/null;&amp;nbsp;\n&amp;nbsp; &amp;nbsp; }\n&amp;nbsp; &amp;nbsp; access_log&amp;nbsp; /www/wwwlogs/sxitw.cn.log;\n&amp;nbsp; &amp;nbsp; error_log&amp;nbsp; /www/wwwlogs/sxitw.cn.error.log;\n}\n&lt;/pre&gt;fuwenben963', 1568625456656, 'liuwk', '使用nginx部署vue-cli项目', '3', 29);
INSERT INTO `blogs` VALUES (111, '程序猿最终的归宿就是送外卖', 'fuwenben963&lt;p&gt;我从来不怀疑中国挣钱的机会越来越多，收入越来越高，中国巨大的规模优势在这里，资金规模，市场规模即使对大多数发达国家也是碾压级别的，拿下的中高端产业越多，那么中高端的就业机会也就越多。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;&quot;&gt;&lt;img src=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;&quot;&gt;&lt;img src=&quot;https://www.1314dy.cn/upfiles/image/201909/20190920010640446.jpg&quot; alt=&quot;Ã§Â¨ÂÃ¥ÂºÂÃ§ÂÂ¿Ã¦ÂÂÃ§Â»ÂÃ§ÂÂÃ¥Â½ÂÃ¥Â®Â¿Ã¥Â°Â±Ã¦ÂÂ¯Ã©ÂÂÃ¥Â¤ÂÃ¥ÂÂ&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;最为典型的就是互联网产业中国发展起来了，如今程序员们成为了高薪群体，互联网产业连带着把顺丰，美团，饿了么之类的快递和物流行业也发展起来了。送外卖成为蓝领岗位中相对高薪的岗位，以至于会有开玩笑说“程序员的最终归宿就是送外卖”。&lt;/p&gt;fuwenben963', 1568941617699, 'liuwk', '我从来不怀疑中国挣钱的机会越来越多，收入越来越高，中国巨大的规模优势在这里', '13', 25);
INSERT INTO `blogs` VALUES (112, '01-webpack安装以及html基本配置', 'fuwenben963&lt;h1&gt;webpack 的安装 从零配置&lt;/h1&gt;&lt;h1&gt;新建一个目录&lt;/h1&gt;&lt;h1&gt;初始化&lt;/h1&gt;&lt;p&gt;&lt;code style=&quot;background-color: rgba(27, 31, 35, 0.05);&quot;&gt;npm init -y&lt;/code&gt;&lt;/p&gt;&lt;h1&gt;安装webpak&lt;/h1&gt;&lt;p&gt;&lt;code style=&quot;background-color: rgba(27, 31, 35, 0.05);&quot;&gt;cnpm i webpack webpack-cli -D&lt;/code&gt;&lt;/p&gt;&lt;h1&gt;默认 webpack 配置文件入口&lt;/h1&gt;&lt;h1&gt;&lt;code style=&quot;background-color: rgba(27, 31, 35, 0.05);&quot;&gt;webpack.config.js&lt;/code&gt;&lt;/h1&gt;&lt;h1&gt;&amp;nbsp;需要自建&lt;/h1&gt;&lt;h1&gt;自定义 wepack 入口文件和打包后的文件名&lt;/h1&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;//  webpack.config.js\n\nlet path = require(&#039;path&#039;) // node 自带的 path\nmodule.exports = {\n    mode:&#039;development&#039;, //模式  production   development\n    entry: &#039;./src/index.js&#039;, //入口\n    output: {\n        filename: &#039;bundel.js&#039;,  //打包后的文件名\n        path:path.resolve(__dirname,&#039;dist&#039;) // __dirname是当前文件目录下的路径， 路径必须是一个绝对路径\n    }\n}\n&lt;/pre&gt;&lt;h1&gt;可能我们需要一个webpack的服务器 那就需要安装 webpack-dev-server&lt;/h1&gt;&lt;p&gt;&lt;code style=&quot;background-color: rgba(27, 31, 35, 0.05);&quot;&gt;cnpm i webpack-dev-server -D&lt;/code&gt;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;let path = require(&#039;path&#039;) // node 自带的 path\nmodule.exports = {\n    devServer:{ // 开发服务器的配置  需要安装  cnpm i webpack-dev-server -D\n        port:9632,\n        progress:true, //进度条\n        contentBase:&#039;./dist&#039;,  // 开发服务器 入口目录\n        open:true  //自动打开浏览器\n    },\n    mode:&#039;development&#039;, //模式  production   development\n    entry: &#039;./src/index.js&#039;, //入口\n    output: {\n        filename: &#039;bundel.[hash:8].js&#039;,  //打包后的文件名  可以生成 hash戳 解决缓存的问题  :8  表示可以生成8位\n        path:path.resolve(__dirname,&#039;dist&#039;) // __dirname是当前文件目录下的路径， 路径必须是一个绝对路径\n    }\n}\n\n// package.json  配置 build(npx webpack) 和 dev(npx webpack-dev-server) 快速启动命令   npm run build or dev\n{\n   ...\n  &quot;scripts&quot;: {\n    &quot;test&quot;: &quot;echo &quot;Error: no test specified&quot; &amp;amp;&amp;amp; exit 1&quot;,\n    &quot;build&quot;: &quot;webpack&quot;,\n    &quot;dev&quot;:&quot;webpack-dev-server&quot;\n  }\n  ...\n}\n\n&lt;/pre&gt;&lt;h1&gt;要是 没有 dist 目录 运行npm run dev 肯定会报错 这时候我们需要建一个html文件模板 安装&amp;nbsp;&lt;/h1&gt;&lt;h1&gt;&lt;code style=&quot;background-color: rgba(27, 31, 35, 0.05);&quot;&gt;cnpm i html-webpack-plugin -D&lt;/code&gt;&lt;/h1&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;\nlet path = require(&#039;path&#039;) // node 自带的 path\n\nlet HtmlWebpackPlugin = require(&#039;html-webpack-plugin&#039;) // 需要安装 cnpm i html-webpack-plugin -D\n\nmodule.exports = {\n    devServer:{ \n        ....\n    },\n    mode:&#039;development&#039;, //模式  production   development\n    entry: &#039;./src/index.js&#039;, //入口\n    output: {\n        ....\n    },\n    plugins:[  //  放着所有的webpack 的插件  数组形式\n        new HtmlWebpackPlugin({\n            template:&#039;./src/index.html&#039;,  // 模板路径\n            filename:&#039;index.html&#039;, // 生成的 名字\n            minify:{\n                removeAttributeQuotes:true, // 可以删除 html 的 &quot;&quot;\n                collapseWhitespace:true, // 生成一行的html\n            },\n            hash:true  //生成 hash戳 解决缓存的问题\n        })\n    ]\n}\n&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;fuwenben963', 1569221099603, 'liuwk', '01-webpack安装以及html基本配置', '3', 46);
INSERT INTO `blogs` VALUES (114, '', '', 0, '', '', '', 10);
INSERT INTO `blogs` VALUES (115, '基于vue-cli3的vue项目移动端样式适配', 'fuwenben963&lt;h2&gt;1，安装 flexible和 postcss-px2rem（命令行安装）&lt;/h2&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;npm install lib-flexible --save\n\nnpm install postcss-px2rem --save\n&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;简要介绍这两个包的用途：&lt;/strong&gt;&lt;/p&gt;&lt;h2&gt;flexible会为页面根据屏幕自动添加&amp;lt;meta name=&#039;viewport&#039; &amp;gt;标签，动态控制initial-scale，maximum-scale，minimum-scale等属性的值。&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;例如在Galaxy S III:&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/977406/201811/977406-20181113173321042-954569911.png&quot;&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;例如在iphone6/7/8:&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/977406/201811/977406-20181113165355522-1145747839.png&quot;&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;postcss-px2rem会将px转换为rem，rem单位用于适配不同宽度的屏幕，根据&amp;lt;html&amp;gt;标签的font-size值来计算出结果，1rem=html标签的font-size值。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;2,&amp;nbsp;&lt;/strong&gt;引入lib-flexible&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;在项目入口文件main.js 中引入lib-flexible&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;import &#039;lib-flexible&#039;\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;注意事项（important）: 由于flexible会动态给页面header中添加&amp;lt;meta name=&#039;viewport&#039; &amp;gt;标签，所以务必请把目录 public/index.html 中的这个标签删除！！！&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;3, 配置postcss-px2rem&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;vue-cli3 构建的项目相较于vue-cli2 构建的项目精简了许多，将一些默认配置进行了更好更严密，让开发变得更高效的封装。具体请看vue-cli官网&amp;nbsp;https://cli.vuejs.org/zh/guide/&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;px2rem的配置放在vue-cli3 项目中&lt;/strong&gt;&lt;strong style=&quot;color: rgb(255, 0, 0);&quot;&gt;vue.config.js&lt;/strong&gt;&lt;strong&gt;中（找不到？可能你是一个新构建的项目，需要手动在项目根目录创建vue.config.js）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;具体配置内容如下：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(73, 73, 73);&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt; 1 module.exports = {\n 2     css: {\n 3         loaderOptions: {\n 4           css: {},\n 5           postcss: {\n 6             plugins: [\n 7               require(&#039;postcss-px2rem&#039;)({\n 8                 remUnit: 37.5\n 9               })\n10             ]\n11           }\n12         }\n13     },\n14 }\n&lt;/pre&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(73, 73, 73);&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;OK，重启项目，两个用于移动端适配的包就这样可以愉快的开始使用了！！！&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;下面来看我们的代码，代码中我们直接用px来写宽高：&lt;/strong&gt;&lt;/p&gt;&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;1 .testclass {\n2   width: 300px;\n3   height: 200px;\n4   background: #e3e3e3;\n5 }\n&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;在浏览器中会是什么样的呢？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/977406/201811/977406-20181113172943742-1959192373.png&quot;&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;没错，已经从px转换成了rem。 what？如果你的没有从px变成rem, 那么你可能需要重启一下项目呦~&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong style=&quot;color: rgb(0, 128, 0);&quot;&gt;温馨提示： remUnit这个配置项的数值是多少呢？？？ 通常我们是根据设计图来定这个值，原因很简单，便于开发。假如设计图给的宽度是750，我们通常就会把remUnit设置为75，这样我们写样式时，可以直接按照设计图标注的宽高来1:1还原开发。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong style=&quot;color: rgb(0, 128, 0);&quot;&gt;那为什么你在这里写成了37.5呢？？？那我们后面专门来讲！&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong style=&quot;color: rgb(0, 128, 0);&quot;&gt;之所以设为37.5，是为了引用像mint-ui这样的第三方UI框架，因为第三方框架没有兼容px2rem ，将remUnit的值设置为设计图宽度（这里为750px）75的一半，即可以1:1还原mint-ui的组件，否则会样式会有变化，例如按钮会变小。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong style=&quot;color: rgb(0, 128, 0);&quot;&gt;既然设置成了37.5 那么我们必须在写样式时，也将值改为设计图的一半。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;fuwenben963', 1569642216954, 'liuwk', '基于vue-cli3的vue项目移动端样式适配，lib-flexible和postcss-px2rem', '3', 9);
INSERT INTO `blogs` VALUES (116, '谈谈我对 立刻出行 共享车的第一次使用', 'fuwenben963&lt;p&gt;立刻共享车，记得是2018年3月份还是4月份注册的， 那时候已经拿驾照3年了，没有碰过车，偶然间，听到同事说，去练车，我在想，你也没有车啊，找我练车干嘛，经了解到，是共享车，感觉好新颖啊，车还有共享的，约好同事，记得，第一次租车的网点，在万胜围地铁站附近&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1569733812024&amp;amp;di=ef38ca1ed171c2031e66e0162c65c765&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fn.sinaimg.cn%2Fauto%2Ftransform%2F256%2Fw660h396%2F20190226%2FEH4Q-htptaqe5687369.jpg&quot;&gt;&lt;/p&gt;&lt;p&gt;提前注册好了，立刻的app，交了499押金，还送了50优惠券，租了辆雪佛兰赛欧3，手自一体的，来到网点，两个新手司机(3年驾照的我)迫不及待的找车，认车牌，找到车，按照app提示开门，进去，打火，然后看档位那些，好吧，貌似就认识R档，只好打开百度查找英文字母对应什么档（老司机不要笑我）&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1569731878307&amp;amp;di=6655abb438ce8d5bdb3911d8587e10a0&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fupload.ikanchai.com%2F2018%2F1012%2F1539313945547.jpg&quot;&gt;&lt;/p&gt;&lt;p&gt;一开始，是我同事开的车，商量好，去大学城，两个新手司机要发车了，开到大马路上，别提有多紧张了，小心翼翼的开上路，看着路上车开的那么快，车又多，我腿不发抖（不是我开，不然，我也是一样，啊哈哈），同事的腿发抖了，抖抖抖，抖到了大学城，大学城是个练车的好地方，路多，车又少，嗯，期间一直说，给我开车吧，同事开了半个多钟，说，给你开吧&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1569732245249&amp;amp;di=b12833260d2bc8cef394b024feb04816&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fn.sinaimg.cn%2Ftranslate%2F24%2Fw500h324%2F20180507%2F8gpm-fzrwiaz4918176.jpg&quot;&gt;&lt;/p&gt;&lt;p&gt;我说好啊，真正的老司机，要开车啦，坐稳，扶好&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1569732341768&amp;amp;di=c7eef624619294e7a6ea13f14f70b6eb&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fimg.mp.sohu.com%2Fupload%2F20170719%2F129828859a654ffa86a11b3a2ab4c04d_th.png&quot;&gt;&lt;/p&gt;&lt;p&gt;换到我坐到了驾驶位，想想当时教练教的，系安全带，调座椅位置，调后视镜，老司机果然不一样，还记得这些，啊哈哈哈，因为路上车少，倒也没有太紧张，只是两手，紧紧抓住方向盘而已，死死的，放下离合，加油门，看，车动了，TMD，老司机的我竟然还没忘记怎么开车，可把我高兴的坏了&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1569732893170&amp;amp;di=66ada08877efe22e7933b571f664fb06&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fimg.bqatj.com%2Fimg%2Fd8c5ac6e19a647bd.jpg&quot;&gt;&lt;/p&gt;&lt;p&gt;车慢慢的走动，油门也轻轻的加，老司机开车要有节凑，没有导航，看到那里车少就往那里走，这感觉，贼爽，连带着整个人都轻松，腿也不抖了，方向盘也单手抓着了，这才是老司机该有的样子。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;期间，和同事换了好几次开车，开了大概2个钟，想着，该还车，回的时候，还是同事开着回的，还是回到万胜围地铁站附近的网点，回到网点停车的时候，因为停车位置太小，同事倒车入库，我也在车上，倒的时候，砰，好了，老司机撞到别人车了，是一辆大众polo,比较旧的车了，polo司机下来看，擦花了，同事赶紧下车，和司机协商，赔了150，那位老司机说：我也是这么过来的，多赔点钱，终成老司机，加油。我在旁边笑了，啊哈哈哈哈哈！&lt;/p&gt;&lt;p&gt;还完车，因为有个50的优惠券，减完才花了20多块，至此，老司机的我和同事搭地铁，各回各家，各找各妈&lt;/p&gt;&lt;p&gt;从那时候开始，我踏上了一条前往老司机的不归路，江湖，也没留下我的传说！&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;现在，立刻出行所有网点都已经没车，据说已经倒闭，蛮可惜的！&lt;/p&gt;fuwenben963', 1569720995399, 'liuwk', '共享车的，记得是2018年3月份还是4月份注册的', '13', 28);

-- ----------------------------
-- Table structure for classify
-- ----------------------------
DROP TABLE IF EXISTS `classify`;
CREATE TABLE `classify`  (
  `label` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `value` int(11) NOT NULL
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of classify
-- ----------------------------
INSERT INTO `classify` VALUES ('视频专区', 1);
INSERT INTO `classify` VALUES ('网站源码', 2);
INSERT INTO `classify` VALUES ('技术教程', 3);
INSERT INTO `classify` VALUES ('网络软件', 4);
INSERT INTO `classify` VALUES ('线报资源', 5);
INSERT INTO `classify` VALUES ('音乐分享', 6);
INSERT INTO `classify` VALUES ('短视频', 7);
INSERT INTO `classify` VALUES ('其他', 13);
INSERT INTO `classify` VALUES ('美女图集', 9);
INSERT INTO `classify` VALUES ('网络歌曲', 10);
INSERT INTO `classify` VALUES ('活动资讯', 11);
INSERT INTO `classify` VALUES ('网站源码', 12);
INSERT INTO `classify` VALUES ('热门资讯', 8);

-- ----------------------------
-- Table structure for friends
-- ----------------------------
DROP TABLE IF EXISTS `friends`;
CREATE TABLE `friends`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `url` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `src` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `createtime` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 8 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of friends
-- ----------------------------
INSERT INTO `friends` VALUES (1, '随心博客', 'http://sxitw.cn/', 'http://sxitw.cn/favicon.ico', '1570868758987');
INSERT INTO `friends` VALUES (2, 'Sanshi 博客', 'http://www.sanshi30.cn/', 'http://www.sanshi30.cn/static/img/logo.jpg', '1570868831170');
INSERT INTO `friends` VALUES (3, '杨青青个人博客', 'https://www.yangqq.com/', 'https://www.yangqq.com/favicon.ico', '1570868899520');
INSERT INTO `friends` VALUES (4, '鑫-个人博客', 'https://www.ilxin.cn/', 'http://ilxin.cn/wp-content/uploads/2019/04/tx3.jpg', '1570868967853');
INSERT INTO `friends` VALUES (5, '一个努力奋斗的少年', 'https://blog.ci0n.cn/', 'https://blog.ci0n.cn/images/avatar.jpg', '1570868987420');
INSERT INTO `friends` VALUES (6, '学习中的小萌新', 'https://www.huangxin.work/', 'https://www.huangxin.work/resource/images/favicon.ico', '1570869002880');

-- ----------------------------
-- Table structure for mailList
-- ----------------------------
DROP TABLE IF EXISTS `mailList`;
CREATE TABLE `mailList`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `createtime` bigint(20) DEFAULT NULL,
  `mobile` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `call` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `describe` longtext CHARACTER SET utf8 COLLATE utf8_general_ci,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 15 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of mailList
-- ----------------------------
INSERT INTO `mailList` VALUES (1, 1570699550679, '13888888888', '杨国强', '杨国强找鸡历史');
INSERT INTO `mailList` VALUES (9, 1570847943861, '13888888888', '杨国强', '找50块的鸡，找50块的鸡，找50块的鸡，找50块的鸡，找50块的鸡，找50块的鸡，找50块的鸡，找50块的鸡，找50块的鸡，找50块的鸡，找50块的鸡，找50块的鸡，找50块的鸡，找50块的鸡，找50块的鸡，');
INSERT INTO `mailList` VALUES (10, 1570848230371, '13888888888', '杨国强', '这次找149块的鸡，这次找149块的鸡，这次找149块的鸡');
INSERT INTO `mailList` VALUES (12, 1570848437545, '13888888888', '杨国强', '杨国强大战苍井空300回合ing');
INSERT INTO `mailList` VALUES (13, 1570848489942, '13888888888', '杨国强', '杨国强大战小泽玛利亚300分钟ing');
INSERT INTO `mailList` VALUES (14, 1570848762620, '13888888888', '杨国强', '杨国强群战波多野结衣、大桥未久、京香Julia、麻生希、天海翼、林由奈、小川阿佐美、姬野尤里/市来美保、吉泽明步，两天两夜，屹立不倒。');

-- ----------------------------
-- Table structure for note
-- ----------------------------
DROP TABLE IF EXISTS `note`;
CREATE TABLE `note`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci,
  `createtime` bigint(20) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 22 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of note
-- ----------------------------
INSERT INTO `note` VALUES (12, '友链', '已添加贵站友链，换一下友链，谢谢\n\n名称：随心博客\n\n网址：http://sxitw.cn/\n\n描述：遇事随心,事事顺心\n\nicon : http://sxitw.cn/favicon.ico', 1568798030093);
INSERT INTO `note` VALUES (13, '翻墙下载地址', 'https://ant.antss024.com/', 1568798041933);
INSERT INTO `note` VALUES (14, '微信公众号账号 密码', '爱优之佳小程序\n286641584@qq.com       aiyou123\n\n\nnewretailmerchant@renqilai.com\nquxiaxcx1', 1568798042722);
INSERT INTO `note` VALUES (15, '宝塔服务器网址', 'http://106.52.232.16:8888/7cb05288\n\nsdmlh7ym      1ba1a559', 1568798043500);
INSERT INTO `note` VALUES (16, '腾讯 25岁 服务器优惠购买链接', 'https://cloud.tencent.com/act/campus', 1568798044188);
INSERT INTO `note` VALUES (20, '调薪申请书', '                                                      调薪申请书\n尊敬的领导：\n    在您百忙之中有件个人的事情想耽误你点时间。 自从2019年2月进入公司工作已经半年多。在此期间,公司领导和同事都给予我很大的帮助，同时我个人的能力也不断提升和进步。我负责的项目也有较大的成果，主要有 新零售后台管理系统  趣匣商家端 社惠团后台管理 社区团购供应商， 以及部分负责完成的 贵港公安局--前后台管理，未完成的 爱动滑板车。\n    目前的薪酬是8000，我认为已经不能和我目前的工作情况相对应。申请公司在充分考虑的情况下给我加薪，我希望能提高薪酬的20%，望公司领导给予酌情考虑,批准为盼! \n    当然在工作中我也存在着很多缺点，我会更加珍惜今后的时间，不断充实自我、丰富自我、完善自我。相信您的信任与我的实力将为我们带来共同的成功! 能为公司贡献自己的力量!  \n\n  \n              谨祝公司前程似锦，兴旺发达！\n                       此致 敬礼\n                                                                                                 \n\n                                                                                                            刘伟坤\n                                                                                                            2019年9月2日', 1568806707563);
INSERT INTO `note` VALUES (21, '资料填写', '广东省广州市番禺区\n东沙村骏盈大厦C栋302\n441424199503175512\n13502520162', 1568949219343);

-- ----------------------------
-- Table structure for statistics
-- ----------------------------
DROP TABLE IF EXISTS `statistics`;
CREATE TABLE `statistics`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `count` int(11) DEFAULT NULL,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `logintime` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of statistics
-- ----------------------------
INSERT INTO `statistics` VALUES (1, 556, '网站访问量', '1571021546571');
INSERT INTO `statistics` VALUES (2, 7, '网站注册量', '1571021546571');

-- ----------------------------
-- Table structure for users
-- ----------------------------
DROP TABLE IF EXISTS `users`;
CREATE TABLE `users`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `password` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `realname` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `createDate` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `logintime` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 17 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of users
-- ----------------------------
INSERT INTO `users` VALUES (1, 'liuwk', '101207302das', '刘伟坤', '1565687953481', '1571017489577');
INSERT INTO `users` VALUES (3, 'lisi', '123', '李四', '1565687953481', '1571017182506');
INSERT INTO `users` VALUES (4, 'zhangsan', '123', '张三', '1565687953481', '1571016142318');
INSERT INTO `users` VALUES (5, 'test', '123', '测试', '1565687953481', '1571016142318');
INSERT INTO `users` VALUES (12, 'xiawei', '123', '夏威', '1565687953481', '1571016142318');
INSERT INTO `users` VALUES (14, '测试1', '123', '测试1', '1565687953481', '1571016142318');
INSERT INTO `users` VALUES (15, '安吉拉', '12345678', '王思聪', '1565687953481', '1571016142318');

-- ----------------------------
-- Table structure for whisper
-- ----------------------------
DROP TABLE IF EXISTS `whisper`;
CREATE TABLE `whisper`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `whisper` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `author` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `createtime` bigint(20) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 11 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of whisper
-- ----------------------------
INSERT INTO `whisper` VALUES (1, '每个人都有梦想，我的梦想是爱你，嗯，它实现了！', 'liuwk', 1569662236950);
INSERT INTO `whisper` VALUES (2, '听说你过的挺好，嗯，我也挺好的，挺好！', 'liuwk', 1569662427449);
INSERT INTO `whisper` VALUES (8, '今天2019年9月29日，星期日，这是我打酱油的第四天，也是微语创建的第二天，想想今天的上班时间该怎么过！', 'admin', 1569720608475);
INSERT INTO `whisper` VALUES (9, '刘伟坤，随心it，随心博客，刘伟坤博客', 'liuwk', 1570698143488);
INSERT INTO `whisper` VALUES (10, '2019-10-12 10:00:21，晚上10点广州车陂撸串', 'liuwk', 1570845621526);

SET FOREIGN_KEY_CHECKS = 1;
